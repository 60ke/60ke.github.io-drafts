[{"title":"终端录屏","date":"2021-04-29T02:09:56.000Z","path":"2021/04/29/终端录屏/","text":"今天突然看到一个书签http://showterm.io,showterm是一个终端录屏工具但是现在,感觉用的人不多了,除了showterm以外还有ttygif,terminalizer,asciinema ttygifC开发的录屏工具,mac下使用brew install ttygif即可安装 录制 ttyrec + 自定义的录制名 保存ttygif + 自定义的录制名 (-s 可设定倍速) 效果示意本来有个13M的比较全的录屏但是gitee只支持1M文件的非登录可见,同时需要注意的是录屏录取的是整个终端,而不是当前的标签页(录屏过程切换其它标签,则切换后的标签的显示内容也会被录下)","tags":[{"name":"shell","slug":"shell","permalink":"https://60ke.github.io/tags/shell/"}]},{"title":"数据结构之子字符串查找","date":"2021-04-16T08:48:01.000Z","path":"2021/04/16/数据结构之子字符串查找/","text":"实现一个查找 substring 的函数。如果在母串中找到了子串，返回子串在母串中出现的下标，如果没有找到，返回 -1，如果子串是空串，则返回 0 。 go语言可以用strings直接实现 1234import &quot;strings&quot;func strStr(haystack string, needle string) int &#123; return strings.Index(haystack, needle)&#125; strings中的index是Rabin–Karp算法实现的实现同样的功能的算法还有sunday算法 kmp算法 相关链接:https://segmentfault.com/a/1190000016554961","tags":[{"name":"go","slug":"go","permalink":"https://60ke.github.io/tags/go/"}]},{"title":"go调用RUST","date":"2021-04-06T02:46:59.000Z","path":"2021/04/06/go调用RUST/","text":"无参函数调用先写一个rust的lib项目生成动态库 1cargo new --lib embed Cargo.toml12345678910111213[package]name = &quot;embed&quot;version = &quot;0.1.0&quot;authors = [&quot;k &lt;2589788697@qq.com&gt;&quot;]edition = &quot;2018&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies][lib]name = &quot;embed&quot;crate-type = [&quot;dylib&quot;] lib.rs12345678910111213141516171819use std::thread;#[no_mangle]fn process()&#123; let handles:Vec&lt;_&gt;=(0..=10).map(|_|&#123; thread::spawn(||&#123; let mut x = 0; for _ in 0..5000000&#123; x += 1 &#125; x &#125;) &#125;).collect(); for h in handles&#123; println!(&quot;thread finished with count=&#123;&#125;&quot;,h.join().map_err(|_|&quot;could not join a thread&quot;).unwrap()); &#125;&#125; 编译运行 cargo build --release得到libembed.dylib 将文件按照如下放置 123456789├── Cargo.lock├── Cargo.toml├── src│ ├── a.out│ ├── interface.h│ ├── lib.rs│ ├── libembed.dylib│ ├── main.c│ └── test.go interface.h1void process(); main.c123456#include &quot;interface.h&quot;int main()&#123; process(); return 0;&#125; 编译运行Cgcc main.c -L. -lembed &amp;&amp; ./a.outPS:linux下编译gcc main.c -L. -lembed -Wl,-rpath=./-Wl,-rpath=./用于指定程序运行寻找库的路径运行结果1234567891011thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000thread finished with count=5000000 test.go123456789101112package main/*#cgo LDFLAGS: -L./ -lembed#include &quot;interface.h&quot;*/import &quot;C&quot;func main() &#123; C.process()&#125; go run test.go结果与C运行一致 有参函数调用 lib.rs123456789101112131415#[repr(C)]pub struct Test&#123; a:u32, b:u32,&#125;#[no_mangle]pub extern &quot;C&quot; fn process(test:*const Test)&#123; unsafe&#123; println!(&quot;&#123;&#125;&quot;,(*test).a); println!(&quot;&#123;&#125;&quot;,(*test).b) &#125;&#125; cargo build --release --out-dir . -Z unstable-options main.c1234567891011121314struct Test&#123; int a; int b;&#125;;extern void process(struct Test *test);int main()&#123; struct Test test = &#123;3,4&#125;; process(&amp;test); return 0;&#125; gcc main.c -L. -lembed -Wl,-rpath=./ &amp;&amp; ./a.out output 1234 interface.h 123456typedef struct Test&#123; int a; int b;&#125; Test;void process(struct Test *test); test.go 123456789101112131415161718package main/*#cgo LDFLAGS: -L./ -lembed -Wl,-rpath=./#include &quot;interface.h&quot; //非标准c头文件，所以用引号typedef struct Test&#123; int a; int b;&#125; Test; #可以放但是不建议(建议放入interface.h)*/import &quot;C&quot;func main() &#123; test := C.Test&#123;a: 3, b: 4&#125; C.process(&amp;test)&#125; 字符串指针返回很多数据结构在跨语言调用,得在各个语言来回解析,比较麻烦,我们直接以json字符串传递解析可以极大的简化问题的处理 lib.rs 123456789101112131415161718192021222324252627282930313233343536373839404142use std::thread;use libc::c_int;use libc::c_char;use std::ffi::&#123;CStr,CString&#125;;use json;#[no_mangle]pub extern &quot;C&quot; fn process(a:c_int)&#123; let handles:Vec&lt;_&gt;=(0..=10).map(|_|&#123; thread::spawn(||&#123; let mut x = 0; for _ in 0..5000000&#123; x += 1 &#125; x &#125;) &#125;).collect(); for h in handles&#123; println!(&quot;thread finished with count=&#123;&#125;&quot;,h.join().map_err(|_|&quot;could not join a thread&quot;).unwrap()); &#125; println!(&quot;&#123;&#125; have done&quot;,a)&#125;#[no_mangle]pub extern &quot;C&quot; fn json_parse(c_buf:*const c_char)-&gt; *const c_char&#123; let c_str = unsafe &#123; CStr::from_ptr(c_buf) &#125;.to_str().unwrap(); let parsed = json::parse(c_str).unwrap(); println!(&quot;&#123;&#125;&quot;,parsed[&quot;a&quot;]); let data = r#&quot; &#123; &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 43, &quot;phones&quot;: [ &quot;+44 1234567&quot;, &quot;+44 2345678&quot; ] &#125;&quot;#; CString::new(data).unwrap().into_raw()&#125; main.c 12345678910#include &quot;interface.h&quot;#include &lt;stdio.h&gt;int main()&#123; process(3); const char *str = &quot;&#123;\\&quot;a\\&quot;: 3&#125;&quot;; const char *ret_str = json_parse(str); printf(&quot;%s\\n&quot;,ret_str); return 0;&#125; interface.h 12void process(int a);const char * json_parse(const char *c_buf); test.go123456789101112131415package main/*#cgo LDFLAGS: -L./ -lembed#include &quot;interface.h&quot; //非标准c头文件，所以用引号*/import &quot;C&quot;import &quot;fmt&quot;func main() &#123; C.process(C.int(3)) ret_ptr := C.json_parse(C.CString(`&#123;&quot;a&quot;:3&#125;`)) fmt.Println(C.GoString(ret_ptr))&#125;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"},{"name":"go","slug":"go","permalink":"https://60ke.github.io/tags/go/"}]},{"title":"M1-vscode-lldb","date":"2021-03-18T01:55:14.000Z","path":"2021/03/18/M1-vscode-lldb/","text":"M1的vscode商店中的lldb当前无法直接使用,通过GitHub issue踩坑操作,最终不完美可用(有时候会崩溃)1.重新编译vscode-lldb 12345678910111213141516171819202122232425262728293031323334353637#lvm and vscode-lldb dependeciessudo port install cmake nodejs15 npm6Building stuffbuild llvmgit clone https://github.com/llvm/llvm-project.gitcd llvm-project ; mkdir build ; cd buildcmake ../llvm -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;lldb&quot;make lldb lldb-serverThat is going to take a while.# create a zip with llvmcd lldbzip -r lldb-m1.zip bin/ lib/liblldb.12.0.0git.dylib lib/liblldb.dylibThe content of the archive will be used by vscode-lldb later.Note that the content of lldb-m1.zip will probably only work on your local machine as a lot of other dependencies are left outside (e.g. debugserver and required libs).# building vscode-lldbgit clone https://github.com/vadimcn/vscode-lldb.gitcd vscode-lldbgit submodule update --init --recursivenpm installmkdir build ; cd buildmkdir lldbmv &lt;location of lldb-m1.zip you create belore&gt; lldb/LLDB_PACKAGE=./lldb-m1.zip cmake ..# replaced x86_64-apple-darwin to aarch64-apple-darwin in CMakeLists.txt and azure-pipelines.yml.make vsix_full# If everything goes well:# mv codelldb-full.vsix codelldb-aarch64-darwin.vsix# Install the official vscode-lldb extension and reload.# Install codelldb-aarch64-darwin.vsix via &quot;Install from VSIX...&quot; in the extension menu of VSCode Exploratory. 2.使用x86调试 rustup default stable-x86_64-apple contral+shift+p 12lddb: use alternate backend&#x2F;usr&#x2F;bin&#x2F;lldb","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"杂谈","date":"2021-03-03T08:31:24.000Z","path":"2021/03/03/杂谈/","text":"数据结构与算法1.数据抽象的能力,把现实中的问题抽象出来2.算法本质上就是通过数据结构解决问题的方法,就像学习一样,先学习了数字加减乘除,方程,微积分等等,才具备解决更加复杂的问题的能力.好的数据结构+好的算法=高效的问题解决","tags":[{"name":"others","slug":"others","permalink":"https://60ke.github.io/tags/others/"}]},{"title":"从零实现nosql数据库","date":"2021-03-03T06:49:43.000Z","path":"2021/03/03/从零实现nosql数据库/","text":"资料:如何从零写一个kv数据库？ - cholerae的回答 - 知乎https://www.zhihu.com/question/59469744/answer/165590616https://codecapsule.com/2012/11/07/ikvs-implementing-a-key-value-store-table-of-contents/https://blog.csdn.net/UnSkyToo/article/details/46574209https://www.lanqiao.cn/courses/1341https://segmentfault.com/a/1190000004359057http://www.jos.org.cn/html/2019/9/5776.htmhttps://zh.wikipedia.org/wiki/计算机科学","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"ubuntu管理员账号添加","date":"2021-03-03T02:59:28.000Z","path":"2021/03/03/ubuntu管理员账号添加/","text":"ubuntu管理员账号添加,百度搜出来的结果很多总是不好用,这里记录一下root用户下操作 1.添加账户adduser username 2.添加sudo权限adduser username sudoORusermod -aG sudo vivek ORsudo usermod -aG sudo vivek ORsudo adduser vivek sudo","tags":[{"name":"linux","slug":"linux","permalink":"https://60ke.github.io/tags/linux/"}]},{"title":"new_mac","date":"2021-02-26T06:41:17.000Z","path":"2021/02/26/new-mac/","text":"git等命令安装1234xcode-select --installsudo xcodebuild -license acceptsudo spctl --master-disable #开启任意来源app安装sudo xattr -rd com.apple.quarantine /Applications/LockedApp.app #另一种开启任意来源app安装 iterm2美化hack nerd font hexo安装ohmyzsh安装设置启用插件 1plugins&#x3D;(git zsh-autosuggestions zsh-syntax-highlighting autojump) shell工具1brew install fzf autojump github ssh key配置生产public key 1ssh-keygen -t rsa -C &quot;i505125461@live.com&quot;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"ios-c环境安装","date":"2021-02-05T06:26:26.000Z","path":"2021/02/05/ios-c环境安装/","text":"相关链接:Compile IOS program from linux commandlineios-toolchain-based-on-clang-for-linux - iphoneos_sdk_en.wiki深入剖析 iOS 编译 Clang LLVMhttps://github.com/okanon/iPhoneOS.sdkhow can I fix the clang ‘stdio.h’ not found error? On iOS 12.1 with unc0ver jailbroken 安装llvmclangiostoolchainlibclangllvmclang等 hello.c 1234#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;);&#125; 编译: clang hello.c 1234hello.c:1:10: fatal error: &#39;stdio.h&#39; file not found#include &lt;stdio.h&gt; ^~~~~~~~~1 error generated. 加入 -isysroot参数:clang -isysroot iPhoneOS13.2.sdk hello.c成功编译运行. 编译c++ 暂未解决clang -isystem iPhoneOS13.2.sdk hello.cpp","tags":[]},{"title":"rust包导入","date":"2021-02-03T02:30:15.000Z","path":"2021/02/03/rust包导入/","text":"rust 新版本导入包使用,可以不用先extern crate只需在cargo.toml声明,然后可直接用use 我们创建个项目codec_test 当rust中同时存在lib.rs,main.rs时无法使用,use crate::types::*错误提示:help: a similar path exists: codec_test::types,这是因为在lib.rs中对于lib.rs来说crate::代表了codec_testcrate本身,而对于main.rs来说则相当于是mian.rs导入了名为codec_test的外部crate 代码验证:tree 12345├── Cargo.toml├── src│ ├── lib.rs│ ├── main.rs│ └── types.rs lib.rs 1pub mod types; cargo.toml 123456789[package]name = &quot;codec_test&quot;version = &quot;0.1.0&quot;authors = [&quot;k &lt;worileqing@163.com&gt;&quot;]edition = &quot;2018&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] main.rs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970use std::convert::From;// use crate::types::Sink;use codec_test::types::Sink;// use codec_test::types::Sink1;pub type U256 = [u8; 32];#[derive(Debug)]pub struct Sink1&#123; pub capacity:usize, pub preamble:Vec&lt;u8&gt;, pub heap:Vec&lt;u8&gt;&#125;fn from(num:u32) -&gt; U256&#123; let mut slice = [0u8;32]; slice[28] = (num&gt;&gt;24) as u8; slice[29] = (num&gt;&gt;16) as u8; slice[30] = (num&gt;&gt;8) as u8; slice[31] = num as u8; slice&#125;impl From&lt;u32&gt; for Sink1 &#123; fn from(num: u32) -&gt; Self &#123; let mut slice = [0u8;32]; slice[28] = (num&gt;&gt;24) as u8; slice[29] = (num&gt;&gt;16) as u8; slice[30] = (num&gt;&gt;8) as u8; slice[31] = num as u8; Sink1&#123; capacity:1 as usize, preamble:slice.into(), heap:Vec::new(), &#125; &#125;&#125;trait Codec:Sized &#123; fn encode(self,sink: &amp;mut Sink);&#125;impl Codec for u32&#123; fn encode(self,sink: &amp;mut Sink)&#123; let tar = from(self); sink.preamble.extend_from_slice(&amp;tar); &#125;&#125;fn main() &#123; let a:u32 = 8; let mut sink = Sink&#123; capacity:1, preamble:Vec::new(), heap:Vec::new(), &#125;; a.encode(&amp;mut sink); println!(&quot;&#123;:?&#125;&quot;,sink); let sink1 = Sink1::from(3); println!(&quot;&#123;:?&#125;&quot;,sink1); let sink2:Sink1 = 4.into(); println!(&quot;sink2 &#123;:?&#125;&quot;,sink2); &#125; types.rs 123456#[derive(Debug)]pub struct Sink&#123; pub capacity:usize, pub preamble:Vec&lt;u8&gt;, pub heap:Vec&lt;u8&gt;&#125; 删除main.rs,将代码放入lib.rs使用cargo test -- --nocapture test验证 1234├── Cargo.toml├── src│ ├── lib.rs│ └── types.rs lib.rs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980pub mod types;use std::convert::From;use crate::types::Sink;// use wasm2ct::types::Sink1;pub type U256 = [u8; 32];#[derive(Debug)]pub struct Sink1&#123; pub capacity:usize, pub preamble:Vec&lt;u8&gt;, pub heap:Vec&lt;u8&gt;&#125;fn from(num:u32) -&gt; U256&#123; let mut slice = [0u8;32]; slice[28] = (num&gt;&gt;24) as u8; slice[29] = (num&gt;&gt;16) as u8; slice[30] = (num&gt;&gt;8) as u8; slice[31] = num as u8; slice&#125;impl From&lt;u32&gt; for Sink1 &#123; fn from(num: u32) -&gt; Self &#123; let mut slice = [0u8;32]; slice[28] = (num&gt;&gt;24) as u8; slice[29] = (num&gt;&gt;16) as u8; slice[30] = (num&gt;&gt;8) as u8; slice[31] = num as u8; Sink1&#123; capacity:1 as usize, preamble:slice.into(), heap:Vec::new(), &#125; &#125;&#125;trait Codec:Sized &#123; fn encode(self,sink: &amp;mut Sink);&#125;impl Codec for u32&#123; fn encode(self,sink: &amp;mut Sink)&#123; let tar = from(self); sink.preamble.extend_from_slice(&amp;tar); &#125;&#125;#[test]fn test() &#123; let a:u32 = 8; let mut sink = Sink&#123; capacity:1, preamble:Vec::new(), heap:Vec::new(), &#125;; a.encode(&amp;mut sink); println!(&quot;&#123;:?&#125;&quot;,sink); let sink1 = Sink1::from(3); println!(&quot;&#123;:?&#125;&quot;,sink1); let sink2:Sink1 = 4.into(); println!(&quot;sink2 &#123;:?&#125;&quot;,sink2); &#125;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"高性能web服务与并发测试","date":"2021-01-22T06:55:28.000Z","path":"2021/01/22/高性能web服务与并发测试/","text":"并发测试工具1.Apache ab2.Python locust3.nodejs loadtest4.weighttp5.Apache JMeter6.wrk 并发Web开发1.Python的并发服务:Flask gevent 多进程WSGI（非gunicorn）,这篇博客已经对并发进行分析测试了,为了防止失联,把代码搬运了: server.py12345678910111213141516171819202122232425262728293031323334353637383940# coding: utf-8# code by https://cpp.la, 2020-04-20# flask + gevent + multiprocess + wsgi from gevent import monkeyfrom gevent.pywsgi import WSGIServermonkey.patch_all() import datetimeimport osfrom multiprocessing import cpu_count, Processfrom flask import Flask, jsonify app = Flask(__name__) @app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])def function_benchmark(): return &quot;hello&quot; def run(MULTI_PROCESS): if MULTI_PROCESS == False: WSGIServer((&#x27;0.0.0.0&#x27;, 8080), app).serve_forever() else: mulserver = WSGIServer((&#x27;0.0.0.0&#x27;, 8080), app) mulserver.start() def server_forever(): mulserver.start_accepting() mulserver._stop_event.wait() for i in range(cpu_count()): p = Process(target=server_forever) p.start() if __name__ == &quot;__main__&quot;: # 单进程 + 协程 run(False) # 多进程 + 协程 # run(True) 2.RUST并发服务rust actix 1234567891011121314use actix_web::&#123;get, web, App, HttpServer, Responder&#125;;#[get(&quot;/&quot;)]async fn index(web::Path((id, name)): web::Path&lt;(u32, String)&gt;) -&gt; impl Responder &#123; format!(&quot;Hello &#123;&#125;! id:&#123;&#125;&quot;, name, id)&#125;#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; &#123; HttpServer::new(|| App::new().service(index)) .bind(&quot;127.0.0.1:8080&quot;)? .run() .await&#125; actix 测试结果: 1234567891011121314151617181920wrk -c100 -t16 -d5s http://127.0.0.1:8080Running 5s test @ http://127.0.0.1:8080 16 threads and 100 connections Thread Stats Avg Stdev Max +/- Stdev Latency 692.92us 671.89us 27.97ms 98.85% Req/Sec 9.29k 829.44 20.49k 97.03% 746546 requests in 5.10s, 58.38MB read Non-2xx or 3xx responses: 746546Requests/sec: 146385.73Transfer/sec: 11.45MB./wrk -c1000 -t16 -d5s http://127.0.0.1:8080Running 5s test @ http://127.0.0.1:8080 16 threads and 1000 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.37ms 1.98ms 78.58ms 93.94% Req/Sec 9.54k 3.48k 86.90k 92.16% 763414 requests in 5.10s, 59.70MB read Non-2xx or 3xx responses: 763414Requests/sec: 149702.90Transfer/sec: 11.71MB 测试机器为8核16线程的服务器,可以看到actix的性能还是相当强大的.另外突然想到了一个问题Linux中本机和本机Socket通信会走网卡吗？ 并发测试起先用了loadtest测试,关于Apache ab,weighttp的性能loadtest中有提到,感觉并不理想,后来使用wrk发现性能更强,故使用wrk测试.wrk支持lua脚本的嵌入调用,支持post,get,等调用,亦可使用lua脚本同时对多个接口进行测试. mul.lua多接口测试脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778-- Resource: http://czerasz.com/2015/07/19/wrk-http-benchmarking-tool-example/-- Module instantiationlocal cjson = require &quot;cjson&quot;local cjson2 = cjson.new()local cjson_safe = require &quot;cjson.safe&quot;-- Initialize the pseudo random number generator-- Resource: http://lua-users.org/wiki/MathLibraryTutorialmath.randomseed(os.time())math.random(); math.random(); math.random()-- Shuffle array-- Returns a randomly shuffled arrayfunction shuffle(paths) local j, k local n = #paths for i = 1, n do j, k = math.random(n), math.random(n) paths[j], paths[k] = paths[k], paths[j] end return pathsend-- Load URL paths from the filefunction load_request_objects_from_file(file) local data = &#123;&#125; local content -- Check if the file exists -- Resource: http://stackoverflow.com/a/4991602/325852 local f=io.open(file,&quot;r&quot;) if f~=nil then content = f:read(&quot;*all&quot;) io.close(f) else -- Return the empty array return lines end -- Translate Lua value to/from JSON data = cjson.decode(content) return shuffle(data)end-- Load URL requests from filerequests = load_request_objects_from_file(&quot;./data/requests.json&quot;)-- Check if at least one path was found in the fileif #requests &lt;= 0 then print(&quot;multiplerequests: No requests found.&quot;) os.exit()endprint(&quot;multiplerequests: Found &quot; .. #requests .. &quot; requests&quot;)-- Initialize the requests array iteratorcounter = 1request = function() -- Get the next requests array element local request_object = requests[counter] -- Increment the counter counter = counter + 1 -- If the counter is longer than the requests array length then reset it if counter &gt; #requests then counter = 1 end -- Return the request object with the current URL path return wrk.format(request_object.method, request_object.path, request_object.headers, request_object.body)end 上面脚本依赖lua的cjson包,其目的是解析/data/requests.json构造对应的request请求. /data/requests.json12345678910111213141516171819[ &#123; &quot;path&quot;: &quot;/path-1&quot;, &quot;body&quot;: &quot;&#123;\\&quot;quote\\&quot;: \\&quot;\\&quot;&#125;&quot;, &quot;method&quot;: &quot;POST&quot;, &quot;headers&quot;: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125; &#125;, &#123; // path 为web服务的url路径 &quot;path&quot;: &quot;/path-2&quot;, &quot;body&quot;: &quot;&#123;\\&quot;quote\\&quot;: \\&quot;\\&quot;&#125;&quot;, &quot;method&quot;: &quot;POST&quot;, &quot;headers&quot;: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125; &#125;] 测试命令./wrk -c100 -t16 -d5s -s ./mul.lua http://127.0.0.1:5000 -c:(concurrent)并发数 -t:(threads)线程数 -d:(duration)持续时间 其它具体使用方法可去看文档及示例: https://github.com/wg/wrk 疑问 测试actix时,cpu,内存,网络占用,都特别低,cpu使用百分之一不到,说明程序还远未达到硬件的性能瓶颈Linux的性能测试工具 Perf","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"rust类属性宏","date":"2021-01-08T03:18:27.000Z","path":"2021/01/08/rust类属性宏/","text":"1.创建macro_test项目cargo new macro_test2.创建macro_test_derive项目实现宏的代码逻辑cargo new macro_test_derive --lib在macro_test_derive的Cargo.toml中声明lib标识proc-macro 12[lib]crate-type = [&quot;proc-macro&quot;] 也可用 12[lib]proc-macro = true 3.宏逻辑代码 123456789101112131415161718use proc_macro::TokenStream;use quote::quote;use cfg_if::cfg_if;#[proc_macro_attribute]pub fn macro_test_derive(attr: TokenStream, input: TokenStream) -&gt; TokenStream &#123; cfg_if!&#123; if #[cfg(feature = &quot;test&quot;)]&#123; println!(&quot;the attr is11 &#123;:?&#125;&quot;,attr.to_string()); &#125; &#125; (quote! &#123; fn hello1()&#123; println!(&quot;it&#x27;s hello1&quot;) &#125; &#125;).into()&#125; 4.main.rs调用宏测试 12345678910use macro_test_derive::macro_test_derive;#[macro_test_derive(K)]fn hello()&#123; unimplemented!()&#125;fn main()&#123; hello1()&#125; 项目地址:https://github.com/60ke/rust_code_test/tree/main/macro_test","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"智能合约sdk开发","date":"2020-12-16T10:39:08.000Z","path":"2020/12/16/智能合约sdk开发/","text":"架构: 123456789+----------------------------------+| standard library |----------------&gt; |合约标准库如 U256 Address等+----------------------------------+| rs contract file |----------------&gt; |rust 合约初始文件+----------------------------------+| rust sdk |----------------&gt; |包装合约初始文件(为其添加deploy,call方法)+----------------------------------+| contract middle layer |----------------&gt; |外部导入虚拟机存储读写接口+----------------------------------+","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"rust num","date":"2020-12-11T07:03:43.000Z","path":"2020/12/11/rust-num/","text":"开发wasm2ct时遇到了这行代码 123construct_uint! &#123; pub struct U256(4);&#125; 宏展开之后为: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869IntellijRustDollarCrate::construct_uint! &#123; @ construct pub struct U256 ( 4 ) ; &#125;impl ::uint::core_::convert::From&lt;u128&gt; for U256 &#123; fn from(value: u128) -&gt; U256 &#123; let mut ret = [0; 4]; ret[0] = value as u64; ret[1] = (value &gt;&gt; 64) as u64; U256(ret) &#125;&#125;impl ::uint::core_::convert::From&lt;i128&gt; for U256 &#123; fn from(value: i128) -&gt; U256 &#123; match value &gt;= 0 &#123; true =&gt; From::from(value as u128), false =&gt; &#123; panic!(&quot;Unsigned integer can&#x27;t be created from negative value&quot;); &#125; &#125; &#125;&#125;impl U256 &#123; /// Low 2 words (u128) #[inline] pub const fn low_u128(&amp;self) -&gt; u128 &#123; let &amp;U256(ref arr) = self; ((arr[1] as u128) &lt;&lt; 64) + arr[0] as u128 &#125; /// Conversion to u128 with overflow checking /// /// # Panics /// /// Panics if the number is larger than 2^128. #[inline] pub fn as_u128(&amp;self) -&gt; u128 &#123; let &amp;U256(ref arr) = self; for i in 2..4 &#123; if arr[i] != 0 &#123; panic!(&quot;Integer overflow when casting to u128&quot;) &#125; &#125; self.low_u128() &#125;&#125;impl ::uint::core_::convert::TryFrom&lt;U256&gt; for u128 &#123; type Error = &amp;&#x27;static str; #[inline] fn try_from(u: U256) -&gt; ::uint::core_::result::Result&lt;u128, &amp;&#x27;static str&gt; &#123; let U256(arr) = u; for i in 2..4 &#123; if arr[i] != 0 &#123; return Err(&quot;integer overflow when casting to u128&quot;); &#125; &#125; Ok(((arr[1] as u128) &lt;&lt; 64) + arr[0] as u128) &#125;&#125;impl ::uint::core_::convert::TryFrom&lt;U256&gt; for i128 &#123; type Error = &amp;&#x27;static str; #[inline] fn try_from(u: U256) -&gt; ::uint::core_::result::Result&lt;i128, &amp;&#x27;static str&gt; &#123; let err_str = &quot;integer overflow when casting to i128&quot;; let i = u128::try_from(u).map_err(|_| err_str)?; if i &gt; i128::max_value() as u128 &#123; Err(err_str) &#125; else &#123; Ok(i as i128) &#125; &#125;&#125; 这里注意到在代码 12345678impl ::uint::core_::convert::From&lt;u128&gt; for U256 &#123; fn from(value: u128) -&gt; U256 &#123; let mut ret = [0; 4]; ret[0] = value as u64; ret[1] = (value &gt;&gt; 64) as u64; U256(ret) &#125;&#125; 中转化u128为u64分为三步: 设置数组[u64;4]存储U256,将u128存到数组前两个位置 存储低位到数组[0],即u128 as u256 存储高位到数组[1],即value &gt;&gt; 64rust 标准库中已经包含了u128的数据类型U128,rust中当大数转小数,例如u128转u64,u64转u32时,使用as关键字,且当大位数超出小位数时,均以最后长度的数字赋值.(额外的关于as的实现与重载(https://github.com/rust-lang/rust/issues/6016)).代码验证 123456789101112131415fn main() &#123; let a = u128::MAX / 2; let b = u64::MAX; println!(&quot;&#123;&#125;&quot;,a); println!(&quot;u64 max &#123;&#125;&quot;,b); println!(&quot;u64 max as u32 &#123;&#125;&quot;,(b-1) as u32); println!(&quot;u32 max &#123;&#125;&quot;,u32::MAX); println!(&quot;Hello, world! &#123;&#125;&quot;,a as u64); println!(&quot;2 &gt;&gt; 1 is &#123;&#125;&quot;,2&gt;&gt;1); println!(&quot;2 &gt;&gt; 2 is &#123;&#125;&quot;,2&gt;&gt;2); println!(&quot;3 &gt;&gt; 1 is &#123;&#125;&quot;,3&gt;&gt;1); println!(&quot;5 &gt;&gt; 1 is &#123;&#125;&quot;,5&gt;&gt;1); println!(&quot;5 &gt;&gt; 2 is &#123;&#125;&quot;,5&gt;&gt;2);&#125;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"rust macro","date":"2020-12-02T10:25:31.000Z","path":"2020/12/02/rust-macro/","text":"先放代码 1234567891011121314151617181920212223242526macro_rules! say_hello &#123; ($arg:expr) =&gt; &#123; println!(&quot;&#123;&#125;&quot;, $arg); &#125;;&#125;macro_rules! re_hello &#123; ($arg:expr) =&gt; &#123; say_hello!($arg); say_hello!($arg) &#125;;&#125;macro_rules! many_greetings &#123; ($times:expr) =&gt; &#123;&#123; for i in 0..$times &#123; re_hello!(i); &#125; &#125;&#125;;&#125;fn main() &#123; let a = &quot;111&quot;; re_hello!(a); many_greetings!(4);&#125;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"rust From<T>","date":"2020-11-17T06:57:08.000Z","path":"2020/11/17/rust-From-T/","text":"在对wasm2contract的开发中遇到了这样的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pub trait TokenInterface &#123; fn constructor(&amp;mut self, _total_supply: u8); fn totalsupply(&amp;mut self) -&gt; u8;&#125;#[derive(Debug)]pub struct TokenEndpoint&lt;T: TokenInterface&gt; &#123; pub inner: T,&#125;impl&lt;T: TokenInterface&gt; From&lt;T&gt; for TokenEndpoint&lt;T&gt; &#123; fn from(inner: T) -&gt; TokenEndpoint&lt;T&gt; &#123; TokenEndpoint &#123; inner: inner &#125; &#125; &#125;impl&lt;T: TokenInterface&gt; TokenEndpoint&lt;T&gt; &#123; pub fn new(inner: T) -&gt; Self &#123; TokenEndpoint &#123; inner: inner &#125; &#125; // pub fn from(inner: T) -&gt; Self &#123; // TokenEndpoint &#123; inner: inner &#125; // &#125; pub fn instance(&amp;self) -&gt; &amp;T &#123; &amp;self.inner &#125;&#125;#[derive(Debug)]pub struct TokenContract&#123; x:u8, y:u8,&#125;impl TokenInterface for TokenContract &#123; fn constructor(&amp;mut self, total_supply: u8) &#123; println!(&quot;&#123;&#125;&quot;,total_supply) &#125; fn totalsupply(&amp;mut self) -&gt; u8 &#123; 32 &#125;&#125;fn main() &#123; let endpoint = TokenEndpoint::from(TokenContract&#123;x:3,y:4&#125;); let endpoint2 = TokenEndpoint::new(TokenContract&#123;x:3,y:4&#125;); let mut test = TokenContract&#123;x:1,y:2&#125;; test.constructor(3); println!(&quot;&#123;:#?&#125; \\n &#123;:#?&#125; &quot;,endpoint.instance(),endpoint2.instance())&#125; 其中 123pub fn from(inner: T) -&gt; Self &#123; TokenEndpoint &#123; inner: inner &#125;&#125; 与 12345impl&lt;T: TokenInterface&gt; From&lt;T&gt; for TokenEndpoint&lt;T&gt; &#123; fn from(inner: T) -&gt; TokenEndpoint&lt;T&gt; &#123; TokenEndpoint &#123; inner: inner &#125; &#125; &#125; 在main函数中最终实现的效果一样。继续探究From&lt;T&gt;From和Into是定义于std：：convert模块中的两个trait。它们定义了from和into两个方法，这两个方法互为反操作。From和Into的内部实现: 123456789101112131415161718pub trait From&lt;T&gt;&#123; fn from(T) -&gt; Self;&#125;pub trait Into&lt;T&gt;&#123; fn into(self) -&gt; T;&#125;fn main()&#123; let string1 = &quot;hello&quot;; let string2 = String::from(&quot;hello&quot;); let string3:String = string1.into(); assert_eq!(string1,string2); assert_eq!(string3,string2);&#125; 对于类型T，如果它实现了From＜U＞，则可以通过T：：from（u）来生成T类型的实例，此处u为U的类型实例。 对于类型T，如果它实现了Into＜U＞，则可以通过into方法来消耗自身转换为类型U的新实例。","tags":[]},{"title":"ewasm虚拟机开发","date":"2020-09-22T03:05:04.000Z","path":"2020/09/22/ewasm虚拟机开发/","text":"准备解析wasm字节码wasm概览wasm指令集wasm类型 wasm包含12种section:每个section包括: section id(大小1字节) section size(格式为u32记录section大小) data(section中保存的内容，格式取决于section id) 每个 section 都是可选的, 如果某个 wasm 模块省略了某个 section, 则等同于存在一个内容为空的 section. https://wasdk.github.io/WasmFiddle/?这个网站可以编译c/c++为wasm格式。用一个简单的例子来说明对wasm二进制的解析: 123int main() &#123; return 42;&#125; 对应的wast格式: 123456789(module (table 0 anyfunc) (memory $0 1) (export &quot;memory&quot; (memory $0)) (export &quot;main&quot; (func $main)) (func $main (; 0 ;) (result i32) (i32.const 42) )) 对应的二进制: 二进制码: 1[&#x27;0x0&#x27;, &#x27;0x61&#x27;, &#x27;0x73&#x27;, &#x27;0x6d&#x27;, &#x27;0x1&#x27;, &#x27;0x0&#x27;, &#x27;0x0&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x85&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x60&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x7f&#x27;, &#x27;0x3&#x27;, &#x27;0x82&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x0&#x27;, &#x27;0x4&#x27;, &#x27;0x84&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x70&#x27;, &#x27;0x0&#x27;, &#x27;0x0&#x27;, &#x27;0x5&#x27;, &#x27;0x83&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x6&#x27;, &#x27;0x81&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x0&#x27;, &#x27;0x7&#x27;, &#x27;0x91&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x2&#x27;, &#x27;0x6&#x27;, &#x27;0x6d&#x27;, &#x27;0x65&#x27;, &#x27;0x6d&#x27;, &#x27;0x6f&#x27;, &#x27;0x72&#x27;, &#x27;0x79&#x27;, &#x27;0x2&#x27;, &#x27;0x0&#x27;, &#x27;0x4&#x27;, &#x27;0x6d&#x27;, &#x27;0x61&#x27;, &#x27;0x69&#x27;, &#x27;0x6e&#x27;, &#x27;0x0&#x27;, &#x27;0x0&#x27;, &#x27;0xa&#x27;, &#x27;0x8a&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x1&#x27;, &#x27;0x84&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x80&#x27;, &#x27;0x0&#x27;, &#x27;0x0&#x27;, &#x27;0x41&#x27;, &#x27;0x2a&#x27;, &#x27;0xb&#x27;] 一步步分析:前八个字节表示的东西是固定的。&#39;0x0&#39;, &#39;0x61&#39;, &#39;0x73&#39;, &#39;0x6d&#39;前四个字节表示\\0asm.&#39;0x1&#39;, &#39;0x0&#39;, &#39;0x0&#39;, &#39;0x0&#39;表示为1的版本号。 wasm采用LEB128编码:谷歌为了省点空间，在安卓中用了这个压缩标准，其原理就是一个4字节32位的数字，一般很少占满，比如数字1，2等，它其实用几位就可以表示。下面看看它的工作原理：1）忽略高字节的正负代表位。2）每七位组成一组，待编码。3）有符号和无符号的分成不同的情况来处理。4）无符号，最高位为0表示结束，1表示还有后续字节。待编码的七位为数据。5）有符号的处理，同上，但需要处理高位为0的不同情况。6）有符号的处理，同上，需要处理高位为1的不同情况。从上面可以看出无符号比较简单，有符号还需要处理几种情况，这里举一个无符号的例子，简单理解一下，更多请查阅相关资料：编码：十六进制数字：0x238 ========&gt; 二进制 0000 0010 0011 1000分成两个七位的组：0000100(高位)， 0111000（低位）0000100后面没数据了，所以前面加一个0；0111000后面还有一个字节，所以高为为1，则变为：00000100(即：0x04),10111000(0x70) 则小端存放的数据为：0x70,0x04解码：正好相反，把数据拆开，按编码逆向过程即可。 对于rust，我们可以直接用现有的crate:parity-wasm对wasm进行解析。 wasm解析器wasmi 可运行wasm的虚拟机vm 生成可被wasmi执行的合约pwasm-abi使用过程宏生成类型solidity合约代码结构的rust合约,并最终编译为wasm-unkonwn-unkonwn(wasm). 最终生成的合约: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#![no_std]#![allow(non_snake_case)]#![feature(proc_macro_hygiene)]extern crate pwasm_std;extern crate pwasm_ethereum;extern crate pwasm_abi;extern crate pwasm_abi_derive;extern crate alloc;pub mod array &#123; use pwasm_ethereum; use pwasm_abi::types::*; use pwasm_abi_derive::eth_abi; use alloc::collections::BTreeMap; use alloc::format; #[eth_abi(TokenEndpoint, TokenClient)] pub trait ArrayInterface &#123; fn constructor(&amp;mut self); fn double_array(&amp;mut self,x:U256,y:U256)-&gt; U256; &#125; pub struct ArrayContract; impl ArrayInterface for ArrayContract&#123; fn double_array(&amp;mut self,x:U256,y:U256) -&gt; U256&#123; U256::from(x) + U256::from(x) &#125; fn constructor(&amp;mut self) &#123; &#125; &#125;&#125;use pwasm_abi::eth::EndpointInterface;#[no_mangle]pub fn call() &#123; let mut endpoint = array::TokenEndpoint::new(array::ArrayContract&#123;&#125;); // Read http://solidity.readthedocs.io/en/develop/abi-spec.html#formal-specification-of-the-encoding for details pwasm_ethereum::ret(&amp;endpoint.dispatch(&amp;pwasm_ethereum::input()));&#125;#[no_mangle]pub fn deploy() &#123; let mut endpoint = array::TokenEndpoint::new(array::ArrayContract&#123;&#125;); endpoint.dispatch_ctor(&amp;pwasm_ethereum::input());&#125; 上面的合约通过eth_abi这个过程宏生成了wasm合约.宏展开的部分代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354fn dispatch(&amp;mut self, payload: &amp;[u8]) -&gt; Vec&lt;u8&gt; &#123; let inner = &amp;mut self.inner; if payload.len() &lt; 4 &#123; ::core::panicking::panic(&quot;Invalid abi invoke&quot;); &#125; let method_id = ((payload[0] as u32) &lt;&lt; 24) + ((payload[1] as u32) &lt;&lt; 16) + ((payload[2] as u32) &lt;&lt; 8) + (payload[3] as u32); let method_payload = &amp;payload[4..]; match method_id &#123; 870935635u32 =&gt; &#123; if pwasm_ethereum::value() &gt; 0.into() &#123; ::core::panicking::panic( &quot;Unable to accept value in non-payable constructor call&quot;, ); &#125; let mut stream = pwasm_abi::eth::Stream::new(method_payload); let result = inner.double_array( stream.pop::&lt;U256&gt;().expect(&quot;argument decoding failed&quot;), stream.pop::&lt;U256&gt;().expect(&quot;argument decoding failed&quot;), ); let mut sink = pwasm_abi::eth::Sink::new(1usize); sink.push(result); sink.finalize_panicking() &#125; _ =&gt; ::core::panicking::panic(&quot;Invalid method signature&quot;), &#125;&#125;fn double_array(&amp;mut self, x: U256, y: U256) -&gt; U256 &#123; #![allow(unused_mut)] #![allow(unused_variables)] let mut payload = Vec::with_capacity(4 + 2usize * 32); payload.push((870935635u32 &gt;&gt; 24) as u8); payload.push((870935635u32 &gt;&gt; 16) as u8); payload.push((870935635u32 &gt;&gt; 8) as u8); payload.push(870935635u32 as u8); let mut sink = pwasm_abi::eth::Sink::new(2usize); sink.push(x); sink.push(y); sink.drain_to(&amp;mut payload); let mut result = [0u8; 32]; pwasm_ethereum::call( self.gas.unwrap_or(200000), &amp;self.address, self.value.clone().unwrap_or(U256::zero()), &amp;payload, &amp;mut result[..], ) .expect(&quot;Call failed; todo: allow handling inside contracts&quot;); let mut stream = pwasm_abi::eth::Stream::new(&amp;result); stream.pop().expect(&quot;failed decode call output&quot;)&#125; 在合约编译的内部实现中通过需要通过eth_abi接口将函数重命名.这样我们在调用合约时,通过eth_abi编码的数据才能被合约识别运行. web3eth_abi编码 wasm-build已生成的wasm合约不能直接被vm运行,wasm-build将由pwasm写的合约再次处理转化为可被vm执行的wasm合约文件. wasm-build的工作:1.解析wasm module提取以下section: 12345678910111213141516while let Some(section) = sections.pop() &#123; match section &#123; elements::Section::Type(sect) =&gt; &#123; types = Some(sect); &#125; elements::Section::Import(sect) =&gt; &#123; import = Some(sect); &#125; elements::Section::Function(sect) =&gt; &#123; funcs = Some(sect); &#125; elements::Section::Table(sect) =&gt; &#123; table = Some(sect); &#125; elements::Section::Memory(sect) =&gt; &#123; memory = Some(sect); &#125; elements::Section::Global(sect) =&gt; &#123; global = Some(sect); &#125; elements::Section::Export(sect) =&gt; &#123; export = Some(sect); &#125; elements::Section::Start(index) =&gt; &#123; start = Some(index); &#125; elements::Section::Element(sect) =&gt; &#123; element = Some(sect); &#125; elements::Section::Code(sect) =&gt; &#123; code = Some(sect); &#125; elements::Section::Data(sect) =&gt; &#123; data = Some(sect); &#125; _ =&gt; &#123;&#125; &#125;&#125; 将wasm的module优化为: Type Import Function Table Memory Global Export Start Code Data other 2.优化函数名及构造函数deploy,call,end等模块.","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"},{"name":"wasm","slug":"wasm","permalink":"https://60ke.github.io/tags/wasm/"}]},{"title":"hexo更改post模板","date":"2020-09-22T02:54:03.000Z","path":"2020/09/22/hexo更改post模板/","text":"运行hexo new post时，现在的模板是 12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 默认无分类在scaffolds更改post.md 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:--- 就好了","tags":[]},{"title":"vscode奇技淫巧","date":"2020-09-18T06:29:16.000Z","path":"2020/09/18/vscode奇淫技巧/","text":"用户代码片段之前在sublime上常用tmpl插件来新建python文件，文件默认包含头文件模板。vscode可以直接添加与文件相关的代码片段。python用户代码片段: 12345678910111213141516171819202122&#123; &quot;HEADER&quot;:&#123; &quot;prefix&quot;: &quot;header&quot;, &quot;body&quot;: [ &quot;#!/usr/bin/env python&quot;, &quot;# -*- encoding: utf-8 -*-&quot;, &quot;&#x27;&#x27;&#x27;&quot;, &quot;@File : $TM_FILENAME&quot;, &quot;@Time : $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;, &quot;@Author : worileqing&quot;, &quot;@Version : 1.0&quot;, &quot;@Contact : worileqing@163.com&quot;, &quot;@Desc : None&quot;, &quot;&#x27;&#x27;&#x27;&quot;, &quot;&quot;, &quot;# here put the import lib&quot;, &quot;$0&quot; ], &#125; &#125; markdown用户代码片段: 123456789101112131415&#123; &quot;HEADER&quot;:&#123; &quot;prefix&quot;: &quot;date&quot;, &quot;body&quot;: [ &quot;date : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;, ], &#125;, &quot;HEADER&quot;:&#123; &quot;prefix&quot;: &quot;code is&quot;, &quot;body&quot;: [ &quot;code is cheap,show code:&quot;, ], &#125; &#125; 但是创建完成配置未能在markdown中生效，解决办法:在setting.json中添加: 1234567&quot;[markdown]&quot;: &#123; &quot;editor.quickSuggestions&quot;: &#123; &quot;other&quot;: true, &quot;comments&quot;: false, &quot;strings&quot;: true &#125;, &#125;, coder runner可以在任意类型的文件里面选中代码 code run by some language","tags":[{"name":"vscode","slug":"vscode","permalink":"https://60ke.github.io/tags/vscode/"}]},{"title":"rust闭包","date":"2020-09-18T06:15:42.000Z","path":"2020/09/18/rust闭包/","text":"概念“闭包（closure）是一种匿名函数，具有“捕获”外部变量的能力。闭包有时候也被称作lambda表达式。它有两个特点：（1）可以像函数一样被调用；（2）可以捕获当前环境中的变量。” 摘录来自: 范长春. “深入浅出Rust。”闭包与函数的显著区别是闭包可以补货变量。 code is cheap,show code: 1234567891011fn add_2(a:i32)-&gt;i32&#123; println!(&quot;run func add_2&quot;); a + 2&#125;fn main()&#123; let a = |x|x+2; println!(&quot;3 + 2 is &#123;&#125;&quot;,a(3)); let b = add_2(3); println!(&quot;b is &#123;&#125;&quot;,b);&#125; 进阶闭包的类型:添加一个返回类型为闭包的函数： 12345678910fn test_return(a:i32)-&gt;Box&lt; Fn(i32)-&gt;i32&gt;&#123; print!(&quot;a is &#123;&#125; but unused\\n&quot;,a); let b = Box::new(|x|x+2); b&#125;fn main() &#123; let c = test_return(3); let d = c(5); println!(&quot;d is &#123;&#125;&quot;,d);&#125; cargo run 123456789101112131415 Compiling just_test v0.1.0 (/Users/ke/Desktop/rust_test/just_test)warning: trait objects without an explicit `dyn` are deprecated --&gt; src/main.rs:2:29 |2 | fn test_return(a:i32)-&gt;Box&lt; Fn(i32)-&gt;i32&gt;&#123; | ^^^^^^^^^^^^ help: use `dyn`: `dyn Fn(i32)-&gt;i32` | = note: `#[warn(bare_trait_objects)]` on by defaultwarning: 1 warning emitted Finished dev [unoptimized + debuginfo] target(s) in 0.36s Running `target/debug/just_test`a is 3 but unusedd is 7 上面的代码有两个需要注意的地方: 返回类型里面的box：rust的闭包又叫unboxed closure 本质是一个unboxed trait,当我们仅返回闭包时编译器会报错return type cannot have an unboxed trait object。因为匿名函数是编译器生成的匿名类型，根本不存在具体对象一说，这意味着它无法有一个明确的 size，所以只能被放置于 堆内存 之中，并取得一个 胖指针 （即除了原始指针以外还包括对指针、指针指向内存的额外描述信息等的 “指针”。故我们需要将closure boxed。 dyn warning:这个问题可以参考:理解 Rust 2018 edition 的两个新关键字 —— impl 和 dyn3.4.1. impl Trait 轻松返回复杂的类型dyn 修饰trait是为了消除与impl trait的歧义，所以我们在了解dyn之前我们需要知道impl Trait:将下面的函数用impl trait重写：12345fn test_return(a:i32)-&gt;Box&lt; Fn(i32)-&gt;i32&gt;&#123; print!(&quot;a is &#123;&#125; but unused\\n&quot;,a); let b = Box::new(|x|x+2); b&#125; 重写:12345fn test_return(a:i32)-&gt; impl Fn(i32)-&gt;i32&#123; print!(&quot;a is &#123;&#125; but unused\\n&quot;,a); let b = Box::new(|x|x+2); b &#125; 测试可以正常运行。impl Trait 是指定实现特定特征的未命名但有具体类型的新方法。重点在于有具体类型。因为有具体类型，匿名函数对于编译器来说是不确定trait，故需要进行box包装来返回，而impl trait由于已经约束了具体类型，所以可以直接作为函数返回类型。 dyn是dynamic(动态的缩写),有了impl trait后使用dyn trait可以更好的与其对应以及消除类型歧义: 1234567891011trait Trait &#123;&#125;impl Trait for i32 &#123;&#125;// oldfn function1() -&gt; Box&lt;Trait&gt; &#123;&#125;// newfn function2() -&gt; Box&lt;dyn Trait&gt; &#123;&#125; 额外的用泛型重写上面的代码: 123456789101112fn calc_by&lt;F&gt;(var: &amp;i32, f: F) -&gt; i32 where F: Fn(&amp;i32) -&gt; i32&#123; let local = *var; f(&amp;local)&#125;fn main() &#123; let local = 10; let result = calc_by(&amp;local, |i| i*2); println!(&quot;&#123;&#125;&quot;, result);&#125;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"rust笔记","date":"2020-09-18T06:13:44.000Z","path":"2020/09/18/rust笔记/","text":"10进制转换为16进制并输出 1assert_eq!(format!(&quot;&#123;:x&#125;&quot;, 42), &quot;2a&quot;); 根据value从列表中获取对应的index （How do I find the index of an element in an array, vector or slice?） 12345fn main() &#123; let test = vec![&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]; let index = test.iter().position(|&amp;r| r == &quot;two&quot;).unwrap(); println!(&quot;&#123;&#125;&quot;, index);&#125; rust int与string的转换 1234let my_string = &quot;27&quot;.to_string(); // `parse()` works with `&amp;str` and `String`!let my_int = my_string.parse::&lt;i32&gt;().unwrap();let my_int: i32 = my_string.parse().unwrap(); rust 合并list实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152extern crate hex;extern crate serde;use std::collections::HashMap;use serde::ser::&#123;Serialize, Serializer, SerializeSeq, SerializeMap, SerializeStruct&#125;;#[macro_use]extern crate serde_derive;type Dictionary = HashMap&lt;String, String&gt;;#[derive(Debug,Serialize, Deserialize,Clone)]pub struct Account &#123; pub address: String, pub balance: usize, pub code: String, pub storage: Dictionary,&#125;#[derive(Debug,Serialize, Deserialize,Clone)]pub struct WriteSet &#123; pub accounts: Vec&lt;Account&gt;, pub gas: usize,&#125;impl Default for WriteSet &#123; fn default() -&gt; WriteSet &#123; WriteSet&#123; accounts: Vec::new(), gas: 0 &#125; &#125;&#125;impl Account&#123; pub fn address(&amp;self) -&gt; String &#123; self.address.clone() &#125;&#125;fn get_write_addrlist(writeset : &amp; WriteSet) -&gt; Vec&lt;String&gt;&#123; // let mut v = Vec::new(); let mut vec: Vec&lt;String&gt; = Vec::new(); for account in &amp;writeset.accounts&#123; vec.push(account.address()) &#125; vec.dedup(); vec&#125;fn push_write_account(mut writeset : WriteSet,accounts:Vec&lt;Account&gt;) -&gt; WriteSet&#123;for account in accounts&#123; let mut writeset_copy = writeset.clone(); let mut writeset_accs = get_write_addrlist(&amp;writeset); if ! writeset_accs.contains(&amp;account.address())&#123; writeset.accounts.push(account); &#125;else&#123; // let index = writeset.accounts.iter(); let index = writeset.accounts.iter().position(|r| r.address == account.address()).unwrap(); for (k,v) in account.storage&#123; writeset.accounts[index].storage.insert(k, v); &#125; // writeset.accounts[index] = account; println!(&quot;index &#123;:?&#125;&quot;, writeset.accounts[index]); &#125;&#125; return writeset&#125;fn main() &#123; let code = &quot;6080604052600436106049576000357c0100000000000000000000000000000\\ 000000000000000000000000000900463ffffffff16806360fe47b114604e57\\ 80636d4ce63c146078575b600080fd5b348015605957600080fd5b506076600\\ 4803603810190808035906020019092919050505060a0565b005b3480156083\\ 57600080fd5b50608a60aa565b6040518082815260200191505060405180910\\ 390f35b8060008190555050565b600080549050905600a165627a7a72305820\\ 99c66a25d59f0aa78f7ebc40748fa1d1fbc335d8d780f284841b30e0365acd9\\ 60029&quot;; let tar = hex::decode(code).unwrap(); println!(&quot;hexo code test &#123;:?&#125;&quot;,tar); let mut struct_tar = WriteSet::default(); struct_tar.accounts.push( Account&#123; address: &quot;&quot;.to_string(), balance: 20, code: &quot;&quot;.to_string(), storage: HashMap::new(), &#125; ); struct_tar.accounts.push( Account&#123; address: &quot;0102&quot;.to_string(), balance: 20, code: &quot;&quot;.to_string(), storage: HashMap::new(), &#125; ); let mut to_insert = HashMap::new(); to_insert.insert(&quot;0&quot;.to_string(),&quot;0&quot;.to_string()); struct_tar.accounts.push( Account&#123; address: &quot;0101&quot;.to_string(), balance: 20, code: &quot;&quot;.to_string(), storage: to_insert.clone(), &#125; ); println!(&quot;struct_tar &#123;:#?&#125;&quot;,struct_tar); let mut addrlist = get_write_addrlist(&amp;struct_tar); println!(&quot;addrlist &#123;:#?&#125;&quot;, addrlist); if ! addrlist.contains(&amp;&quot;11&quot;.to_string())&#123; addrlist.push(&quot;11&quot;.to_string()) &#125; println!(&quot;addrlist &#123;:#?&#125;&quot;, addrlist); let mut to_insert1 = HashMap::new(); to_insert1.insert(&quot;0&quot;.to_string(),&quot;1010&quot;.to_string()); to_insert1.insert(&quot;1&quot;.to_string(),&quot;1010&quot;.to_string()); let mut to_insert2 = HashMap::new(); to_insert2.insert(&quot;0&quot;.to_string(),&quot;1010&quot;.to_string()); to_insert2.insert(&quot;1&quot;.to_string(),&quot;1010&quot;.to_string()); let mut to_push = Vec::new(); to_push.push(Account&#123; address: &quot;0101&quot;.to_string(), balance: 20, code: &quot;&quot;.to_string(), storage: to_insert1, &#125;); to_push.push(Account&#123; address: &quot;0102&quot;.to_string(), balance: 20, code: &quot;&quot;.to_string(), storage: to_insert2, &#125;); let mut res = push_write_account(struct_tar, to_push); println!(&quot;&#123;:#?&#125;&quot;, res); let aa = format!(&quot;&#123;:x&#125;&quot;, 42); println!(&quot;&#123;&#125;&quot;,&quot;0x&quot;.to_string() + &amp;aa); println!(&quot;&#123;:?&#125;&quot;, &quot;4322065350&quot;.to_string().parse::&lt;u128&gt;().unwrap());&#125;","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"大牛博客","date":"2020-09-09T06:28:24.000Z","path":"2020/09/09/大牛博客/","text":"感觉这个不适合放备忘录，博客地址评论区更新吧！","tags":[{"name":"笔记","slug":"笔记","permalink":"https://60ke.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"杂记","date":"2020-09-09T03:27:58.000Z","path":"2020/09/09/杂记/","text":"hexo deploay error运行hexo d时出现type erro的错误:解决办法:放弃使用nodejs 14，转而使用nodejs 12mac 多版本node共存:参考自: https://www.cnblogs.com/hanxiaobei/p/13122144.html 1、首先安装n模块 npm install -g n 2、升级node.js到最新稳定版 sudo n stable 3、切换使用版本（如果本地没有会自动获取并进行安装） sudo n 8.17.0 4、切换使用版本可进行自助选择目前本地安装的版本 sudo n 5、删除指定版本 sudo n rm 0.0.0 git pull解决冲突从其它git clone了一个项目，本地又对其进行了修改，这时运行git pull时将不会成功拉取更新 解决可以先执行git stash 将本地修改保存起来。 这样本地就干净了。然后 git pull然后应用stash。 执行 git stash apply 0。解决本地的冲突就好了。 原理git stash 命令是储藏命令。 1. 可以用来储藏工作的中间状态， 2. 也可以将储藏好的中间状态应用到现有的工作中。 主要的命令有 1. git stash 当本地有修改的时候，只要运行git stash 就可以将本地的更改储藏起来。 2. git stash list 可以用来查看储藏起来的状态。如下 stash@&#123;0&#125;: WIP on master: ece766d package struct 3. git stash apply 可以用来应用储藏的状态。比如 git stash apply 0 就会应用储藏id为0 的中间状态。","tags":[{"name":"other","slug":"other","permalink":"https://60ke.github.io/tags/other/"}]},{"title":"rust测试","date":"2020-09-09T02:40:25.000Z","path":"2020/09/09/rust测试/","text":"println! in rust test参考：Why doesn’t println! work in Rust unit tests? 1234567891011121314151617use std::fs::File;use std::path::Path;use std::io::prelude::*;fn read_file(path: &amp;Path) &#123; let mut file = File::open(path).unwrap(); let mut contents = String::new(); file.read_to_string(&amp;mut contents).unwrap(); println!(&quot;&#123;&#125;&quot;, contents);&#125;#[test]fn test_read_file() &#123; let path = &amp;Path::new(&quot;/etc/hosts&quot;); println!(&quot;&#123;:?&#125;&quot;, path); read_file(path);&#125; 123rustc --test main.rs; .&#x2F;main.&#x2F;main --nocapturecargo test -- --nocapture","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"获取ipa、脱壳","date":"2020-03-20T13:19:49.000Z","path":"2020/03/20/获取脱壳ipa/","text":"获取ipa1.抓包获取1.手机上有thos可以实现全局抓包获取特别注意的是，手机的全局代理在运行商店的时候，网络可能会出现问题。比较稳妥的操作是连2.4G的wifi(5Gwifi商店没网了但是其它APP正常，不知道是不是thos版本的问题)，提前购买了APP(这样可以避免下载的时候的账号验证)2.电脑上可以使用Charles或者其他抓包工具抓包可以获取到App Store的ipa链接，可以直接http下载。但是下载下来的ipa文件无法解压。 2.使用appleconfigurator 2使用苹果自己的软件，登录账户，在操作菜单中点击添加找到自己想获取的app，提示app已存在时，不做任何操作，打开finder command+shift+g 到~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/就能看到ipa文件了，值得注意的是这里的ipa可解压。不过有加壳。先看解压的文件结构： 123456789tree├── META-INF│ ├── com.apple.FixedZipMetadata.bin│ └── com.apple.ZipMetadata.plist├── Payload│ └── caiyunInterpreter.app├── iTunesArtwork└── iTunesMetadata.plist 显示caiyunInterpreter.app的包内容，可以按文件大小排序可以看到最大的二进制文件caiyunInterpreter。 1234567otool -l caiyunInterpreter |grep crypt cryptoff 16384 cryptsize 8273920 cryptid 1 cryptoff 16384 cryptsize 8945664 cryptid 1 使用otool命令，查看cyptid。其值为1表示加壳，0表示未加壳。 脱壳1.Clutch脱壳工具Clush可在github上看到源代码。下载其编译好后的二进制，scp到手机的/usr/bin目录。使用Clutch -i查看已安装的软件列表 12345678910Installed apps:1: QQ邮箱 &lt;com.tencent.qqmail&gt;2: 微信 &lt;com.tencent.xin&gt;3: 优酷视频-刘老根3精彩呈现 &lt;com.youku.YouKu&gt;4: 米家-精品商城 智能生活 &lt;com.xiaomi.mihome&gt;5: YouTube &lt;com.google.ios.youtube&gt;6: 当当-9.9元超值购物秒杀 &lt;com.dangdang.iphone&gt;7: 有道云笔记 - 扫描王版 &lt;com.youdao.note.iphone&gt;8: 拉勾招聘-互联网求职找工作必备 &lt;com.lagou.lagouhr&gt;9: 支付宝 - 让生活更简单 &lt;com.alipay.iphoneclient&gt; 对微信进行脱壳： 1Clutch -d com.tencent.xin 当然了并不能成功。 2.dumpdecrypteddumpdecrypted也是在github上有源代码，但是需要自己编译。下载源码运行make的时候报错了，错误信息大致如下： 1234567xcrun: error: SDK &quot;iphoneos&quot;cannot be locatedxcrun: error: unableto lookup item &#x27;Path&#x27;inSDK &#x27;iphoneos&#x27;clang: warning: nosuch sysroot directory: &#x27;-F/System/Library/Frameworks&#x27; [-Wmissing-sysroot]dumpdecrypted.c:27:10:fatal error: &#x27;stdio.h&#x27; file not found 无法找到对应的 SDK 和 stdio.h 文件, 这种问题大多数是 Xcode 路径造成的. 使用下面的命令看一下系统指向的 Xcode 路径: 1234xcode-select -p/Library/Developer/CommandLineTools 显然不是 Xcode 的路径, 那只能重新切换一下其路径即指向正确的 Xcode 路径即可. 命令如下: 123456789sudo xcode-select --switch /Applications/Xcode.appmaketree.├── Makefile├── README├── dumpdecrypted.c├── dumpdecrypted.dylib└── dumpdecrypted.o 编译 dumpdecrypted成功.然后需要对dumpdecrypted.dylib进行签名两种方式：1.ldidldid -S dumpdecrypted.dylib2.codesign 1codesign -f -s - ./dumpdecrypted.dylib scp到ios /usr/bin具体使用教程可百度 3.binject以上的两个脱壳软件针对的是ios11之前了，binject可支持ios11–ios11.2。由于现在都是IOS13了直接跳过。 4.crackerxi (ios11–ios13)cydia添加源http://cydia.iphonecake.com/,setting除了fakesign都打钩，直接生成脱壳后的ipa一步到位。","tags":[{"name":"ios","slug":"ios","permalink":"https://60ke.github.io/tags/ios/"},{"name":"逆向","slug":"逆向","permalink":"https://60ke.github.io/tags/%E9%80%86%E5%90%91/"}]},{"title":"homebrew的坑","date":"2020-03-18T12:39:03.000Z","path":"2020/03/18/homebrew的坑/","text":"现在python最新版本是3.8，brew默认安装的python3是3.7。于是乎想给python升级，突然发现brew安装的文件夹/usr/local/Cellar下面有多个python3的文件夹，但是运行brew list的时候只显示一个python3，看起来用brew是没法卸载了。惨的是之前安装的openssl里面也有1.0,1.1两个文件夹。但是卸载1.0的时候也对应的是1.1，而且还没生效。 1.卸载openssl 1.01.删除brew 安装的文件夹 /usr/local/Cellar/openssl2.查看有没有软连接ls -al /usr/local/bin/openssl以及ls -al /usr/local/opt/openssl，有则删除 2.启用opensslbrew link openssl 3.清理无效的系统变量和软连接1.先查看环境变量echo $PATH确定哪些无效有时候可能一下子找不到，知道系统的环境变量的加载顺序可以用的上： 1234567/etc/profile/etc/paths /etc/paths.d/~/.bash_profile ~/.bash_login~/.profile~/.bashrc /etc/profile和/etc/paths， /etc/paths.d/是系统级别的，系统启动就会加载；2.在系统环境变量里删除无效的软连接可以用这个bash删除指定目录下的无效软连接： 123456789101112131415161718#! /bin/bashecho &quot;enter scan path: &quot;read pathif [ -z $path ]then echo &quot;please enter scan path&quot; exitfifor file in $(find $path -type l)do if [ ! -e $file ] then echo &quot;rm $file&quot; rm -f $file fidone 4.安装python 3.81.运行brew 安装brew install python@3.8，特别的运行pip3 install packages时如果提示权限问题，可以加--user参数。2.调整系统变量使python3生效像python3这样的一般brew安装完，会直接调用brew link python3使系统的环境变量生效，如果没有可以手动运行一遍，按照提示继续操作。","tags":[{"name":"mac","slug":"mac","permalink":"https://60ke.github.io/tags/mac/"},{"name":"homebrew","slug":"homebrew","permalink":"https://60ke.github.io/tags/homebrew/"}]},{"title":"python多线程没变快？","date":"2020-03-18T12:25:04.000Z","path":"2020/03/18/python多线程没变快?/","text":"先看代码： 12345678910111213141516171819202122232425262728import datetime,timestart_time = datetime.datetime.now()print()for i in range(10000): # time.sleep(0.01) print(i)print(str(datetime.datetime.now() - start_time))from multiprocessing.dummy import Pool as ThreadPooldef main(x): # time.sleep(0.01) print(x)start_time = datetime.datetime.now()l = [x for x in range(10000)]pool = ThreadPool(1000)pool.map(main, l)pool.close()pool.join()print(str(datetime.datetime.now() - start_time)) 当将time的那段代码注释时，多线程没有单线程跑得快，当取消注释时，多线程跑的快。说明带代码单一的暂停，阻塞时多线程快，当代码没有阻塞时，将一个任务拆分为多线程时，反而会将代码运行的速度变慢。","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"}]},{"title":"openvpn","date":"2020-03-06T15:01:35.000Z","path":"2020/03/06/openvpn文件合并/","text":"mac运行openvpn123456789brew install openvpnsudo brew services start openvpnln -s /usr/local/opt/openvpn/sbin/openvpn /usr/local/bin/openvpn命令行运行：sudo openvpn --config (confpath)/siccs.conf#sudo openvpn --config ~/siccs_v1.ovpn后台运行：sudo openvpn --config (confpath)/siccs.conf —daemon openvpn文件合并把ca.crt证书放入client.ovpn配置文件 如果你有好几个网站的openvpn配置你可以在config目录下为每一个网站建一个文件夹，也可以都放在config目录下，不过是不是有很多.crt和.key文件很烦人呀，其实你可以把它们都删除了，只需要把他们放入client.ovpn配置文件。 用写字板打开各个client.ovpn文件在最后面添加 key-direction 1 用记事本打开ca.crt把文件内容复制到和的中间， 用记事本打开client.crt把文件内容复制到和的中间， 用记事本打开client.key把文件内容复制到和的中间， 用记事本打开ta.key把文件内容复制到和的中间， （ca.crt、client.crt、client.key、ta.key这些文件不一定全都与，有那些就修改那些；这些文件的名字不一定都是这样，可以在.ovpn配置文件里搜索ca、cert、key、tls-auth看他们所对应的文件名） 修改完成后删除类似 tls-auth ta.key 1ca ca.crtcert client.crtkey client.key 的那几行，然后保.ovpn文件即可删除那些.crt和.key文件而正常使用了（你可以把密码都保存在一个文件夹下，修改如下：把：auth-user-pass 改成： auth-user-pass pwd/mypass.txt 并在client.ovpn所在目录建立pwd文件夹并在此文件夹下建mypass.txt文件…）。 以上内容Copy自http://www.360doc.com/content/16/0114/15/4171006_527867246.shtml，注意的是key-direction 1必须得有。","tags":[{"name":"mac","slug":"mac","permalink":"https://60ke.github.io/tags/mac/"},{"name":"others","slug":"others","permalink":"https://60ke.github.io/tags/others/"}]},{"title":"Mac安装LaTeX","date":"2020-03-06T14:46:14.000Z","path":"2020/03/06/Mac安装LaTeX/","text":"由于现在网上很多软件文档都是基于Sphinx写成的，例如：https://solidity-cn.readthedocs.io/zh/develop/，离线阅读难免不便好在借助Sphinx的rst文件可以生成对应的pdf，epub，html等类型。这里以https://github.com/etherchina/solidity-doc-cn为例： 安装环境mac下的LaTeX有两种：1.mactex(这个安装包较大)brew cask install mactex2.BasicTeXbrew cask install basictex 在项目目录下使用命令make --help查看: 123456789101112131415161718192021222324252627282930313233343536373839Usage: make [options] [target] ...Options: -b, -m Ignored for compatibility. -B, --always-make Unconditionally make all targets. -C DIRECTORY, --directory=DIRECTORY Change to DIRECTORY before doing anything. -d Print lots of debugging information. --debug[=FLAGS] Print various types of debugging information. -e, --environment-overrides Environment variables override makefiles. -f FILE, --file=FILE, --makefile=FILE Read FILE as a makefile. -h, --help Print this message and exit. -i, --ignore-errors Ignore errors from commands. -I DIRECTORY, --include-dir=DIRECTORY Search DIRECTORY for included makefiles. -j [N], --jobs[=N] Allow N jobs at once; infinite jobs with no arg. -k, --keep-going Keep going when some targets can&#x27;t be made. -l [N], --load-average[=N], --max-load[=N] Don&#x27;t start multiple jobs unless load is below N. -L, --check-symlink-times Use the latest mtime between symlinks and target. -n, --just-print, --dry-run, --recon Don&#x27;t actually run any commands; just print them. -o FILE, --old-file=FILE, --assume-old=FILE Consider FILE to be very old and don&#x27;t remake it. -p, --print-data-base Print make&#x27;s internal database. -q, --question Run no commands; exit status says if up to date. -r, --no-builtin-rules Disable the built-in implicit rules. -R, --no-builtin-variables Disable the built-in variable settings. -s, --silent, --quiet Don&#x27;t echo commands. -S, --no-keep-going, --stop Turns off -k. -t, --touch Touch targets instead of remaking them. -v, --version Print the version number of make and exit. -w, --print-directory Print the current directory. --no-print-directory Turn off -w, even if it was turned on implicitly. -W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE Consider FILE to be infinitely new. --warn-undefined-variables Warn when an undefined variable is referenced. 通过help可以看出我们可以编译pdf、epub等类型文件（make过程可能造成编码错误）。","tags":[{"name":"mac","slug":"mac","permalink":"https://60ke.github.io/tags/mac/"}]},{"title":"Enclave开发","date":"2020-01-17T08:58:55.000Z","path":"2020/01/17/Enclave开发/","text":"Enclave开发包括以下几个步骤： 使用EDL文件定义不可信app和encalve(飞地)之间的接口(由ecall和ocall来实现) 实现app和encalve函数。 编译app和enclave。编译中，Edger8r生成可信和不可信的代理/桥函数，enclave签名工具生成enclave的metadata和签名。需生成Enclave_private.pem 在模拟和硬件模式下运行和调试app，详细看看调试飞地的内容。 准备发布app和飞地。 名词解释 EDL 即 Enclave Defination Language. 因为 Enclave 不同于共享的资源, 其与外部不可信内容的交互需要特定的规则进行限定. Intel SGX 给出了一种语言来抽象地描述 Enclave 内部函数的调用权限和数据的出入方式, 并通过 sgx_edger8r 翻译成一系列可编译的代码.EDL 提出了一种“边规则”(edge routine) 的概念. 一个 edge routine 即是运行于 Enclave 内部或外部的函数和它们与 Enclave 外部或内部的调用关系的总称. ecall（Enclave Call） 是 Enclave 内部程序的接口函数. ocall （Out Call）是可由 Enclave 内部代码调用的外部函数接口. 具体开发实例https://github.com/60ke/rust_sgx_test/tree/master/ocall_beta 此实例是基于incubator-teaclave-sgx-sdk 即baidu rust sdk开发 开发流程： 首先需要放置基础依赖common/inc（c的头文件）和 edl 使用rust编写 app 和 encalve 编写Makefile文件(可参考Makefile) 1 和 3 的开发相对简单，不再具体描述。下面介绍使用rust编写 app 和 encalve 代码结构： 123456789101112131415161718192021├── .vscode-------------------------- vscode配置文件，用于debug├── Cargo.toml-------------------------- 定义workspace用于debug├── Makefile-------------------------- 项目编译├── app│ ├── Cargo.toml-------------------------- app的cargo配置│ ├── build.rs-------------------------- app的build文件│ └── src -------------------------- rust代码目录│ └── main.rs-------------------------- app主函数文件├── bin-------------------------- 存放编译后的二进制文件夹├── common-------------------------- 引用自[common&#x2F;inc](https:&#x2F;&#x2F;github.com&#x2F;mesalock-linux&#x2F;adler32-rs-sgx&#x2F;tree&#x2F;master&#x2F;sgx&#x2F;adler32-rs-sgx-test&#x2F;common&#x2F;inc)├── edl-------------------------- 引用自[edl](https:&#x2F;&#x2F;github.com&#x2F;mesalock-linux&#x2F;adler32-rs-sgx&#x2F;tree&#x2F;master&#x2F;sgx&#x2F;adler32-rs-sgx-test&#x2F;edl)├── enclave│ ├── Cargo.toml-------------------------- enclave的cargo配置│ ├── Enclave.config.xml--------------定义 Enclave 的内存布局等高级特性│ ├── Enclave.edl--------------Edl文件│ ├── Enclave.lds--------------encalve链接脚本│ ├── Enclave_private.pem------------用户生成的私匙供 sgxsdk 签名使用│ ├── Makefile -------------------------- Encalve编译│ └── src -------------------------- rust代码目录│ └── lib.rs-------------------------- enclave的lib文件 首先在encalve的Enclave.edl中定义ecall和ocall函数 123456789101112131415161718enclave &#123; //导入引用 from &quot;sgx_tstd.edl&quot; import *; from &quot;sgx_stdio.edl&quot; import *; from &quot;sgx_backtrace.edl&quot; import *; from &quot;sgx_tstdc.edl&quot; import *; include &quot;sgx_quote.h&quot; trusted &#123; //定义ecall public sgx_status_t say_something([in, size=len] const uint8_t* some_string, size_t len); &#125;; untrusted &#123; //定义ocall void ocall_get_quote([in, size = key_len] uint8_t * key,uint32_t key_len,[out,size = 1000] uint8_t* value,[out] uint8_t* value_len); &#125;;&#125;; ecall的入口在app部分，函数的具体实现在enclave中。先看ecall的edl函数定义： 1public sgx_status_t say_something([in, size=len] const uint8_t* some_string, size_t len); 这里ecall的调用传入的是一个c语言的常量字符串，为了便于c与rust的交互我们将char list(常量字符串)转换为ASCII码以指针的形式传递。这里的ecall直接使用incubator-teaclave-sgx-sdk中的Enclave.edl 首先声明public，返回的数据类型为sgx_status_t 函数名为say_something.ecall传入enclave需要用[in]修饰。由于我们传入的为常量需要加上size的参数size=len Edl的语法和C语言语法比较接近uint8_t*和size_t为数据类型，some_string 和为变量名len. enclave的say_something实现：lib.rs，然后在app中引入： 1234extern &#123; fn say_something(eid: sgx_enclave_id_t, retval: *mut sgx_status_t, some_string: *const u8, len: usize) -&gt; sgx_status_t;&#125; 然后在main.rs中的main函数对其调用。 ocall的入口在enclave中，函数在app中实现。其Edl部分为： 1void ocall_get_quote([in, size = key_len] uint8_t * key,uint32_t key_len,[out,size = 1000] uint8_t* value,[out] uint8_t* value_len); ocall的实现的功能为由enclave传出一个key到app，然后app生成一个对应的value再传入enclave。整体流程与ecall类似。需要注意的是，由于value的长度不固定，不能单纯定义为一个常量的类型。我们这里先定义了一个足够大的list（1000），然后再传递一个变量value_len来表示value的长度。然后在enclave对其进行截取来实现value由app到enclave的返回。 参考https://blog.lao-yuan.com/2019/02/20/Linux-SGX-Demo.html#edlhttps://zhuanlan.zhihu.com/p/39914622","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"},{"name":"sgx","slug":"sgx","permalink":"https://60ke.github.io/tags/sgx/"}]},{"title":"sgx开发","date":"2020-01-17T08:46:35.000Z","path":"2020/01/17/sgx/","text":"sgx 开发当前项目依赖：incubator-teaclave-sgx-sdk 1.0.9(原baidu rust sgx sdk) Rust nightly-2019-08-01 https://github.com/enigmampc/enigma-core 的一些crate(后续开发剔除) 适用于rust sgx的crate： https://github.com/dingelish/sgx-world 项目开发遇到的问题evm读写集的记录：在sputnikvm的返回结果上添加读写集。可对比 https://github.com/60ke/sputnikvm 与 https://github.com/enigmampc/sputnikvm/tree/enigma-next 的区别 ocall：传入address和storage的key来获取storage的value的edl部分的代码： 12345void ocall_get_storage([in, size = addr_len] uint8_t * addr,uint8_t addr_len,[in, size = index_len] uint8_t * index,uint8_t index_len,[out,size = 1000] uint8_t* value,[out] uint8_t* value_len); enclave与外界的数据类型交互：由edl生成c函数，通过指针的方法进行进行交互 solidity测试合约regchain wiki中的合约： 12345678pragma solidity ^0.4.24;contract sample &#123; uint256 a &#x3D; 0; function add() payable public returns (uint256) &#123; a &#x3D; a + msg.value; return a; &#125;&#125; 需要操作storage的合约： 1234567891011121314151617pragma solidity ^0.4.24;contract MyContract &#123; uint[] array &#x3D; [1,2,3,4,5]; function removeAtIndex(uint index) returns (uint[]) &#123; if (index &gt;&#x3D; array.length) return; for (uint i &#x3D; index; i &lt; array.length-1; i++) &#123; array[i] &#x3D; array[i+1]; &#125; delete array[array.length-1]; array.length--; return array; &#125;&#125; 利用vscode和sgx-gdb进行调试教程： Setup gdb 7.11 on Ubuntu 18.04 for VSCode sgx gdb remote debugging 对应代码实例： hello-rust-vscode-debug intel远程证实 英特尔官方远程证实注册英特尔开发者账号获取spid和key: https://software.intel.com/registration/?lang=zh-cn intel官方实例：https://software.intel.com/zh-cn/articles/code-sample-intel-software-guard-extensions-remote-attestation-end-to-end-example Rust sgx相关代码实例： mutual-ra ue-ra 第三方远程证实（dcap） https://github.com/intel/SGXDataCenterAttestationPrimitives Sgx第三方远程证实硬件说明 ARM TrustZone:OP-TEE / optee_os ARMmbed / meta-mbl https://blog.csdn.net/shuaifengyun/article/details/73716352","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"},{"name":"sgx","slug":"sgx","permalink":"https://60ke.github.io/tags/sgx/"}]},{"title":"CA证书","date":"2019-12-19T04:08:35.000Z","path":"2019/12/19/CA证书/","text":"之前没接触过证书加密的话,对证书相关的这些概念真是感觉挺棘手的,因为一下子来了一大堆新名词,看起来像是另一个领域的东西,而不是我们所熟悉的编程领域的那些东西,起码我个人感觉如此,且很长时间都没怎么搞懂.写这篇文章的目的就是为了理理清这些概念,搞清楚它们的含义及关联,还有一些基本操作. SSLSSL - Secure Sockets Layer,现在应该叫”TLS”,但由于习惯问题,我们还是叫”SSL”比较多.http协议默认情况下是不加密内容的,这样就很可能在内容传播的时候被别人监听到,对于安全性要求较高的场合,必须要加密,https就是带加密的http协议,而https的加密是基于SSL的,它执行的是一个比较下层的加密,也就是说,在加密前,你的服务器程序在干嘛,加密后也一样在干嘛,不用动,这个加密对用户和开发者来说都是透明的 OpenSSL - 简单地说,OpenSSL是SSL的一个实现,SSL只是一种规范.理论上来说,SSL这种规范是安全的,目前的技术水平很难破解,但SSL的实现就可能有些漏洞,如著名的”心脏出血”.OpenSSL还提供了一大堆强大的工具软件,强大到90%我们都用不到. 证书标准X.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考RFC5280,SSL使用的就是这种证书标准. 编码格式同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式. PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -nooutApache和*NIX服务器偏向于使用这种编码格式. DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -nooutJava和Windows服务器偏向于使用这种编码格式. 相关的文件扩展名这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式. CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别. CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码. KEY - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.查看KEY的办法:openssl rsa -in mykey.key -text -noout如果是DER格式的话,同理应该这样了:openssl rsa -in mykey.key -text -noout -inform der CSR - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.查看的办法:openssl req -noout -text -in my.csr (如果是DER格式的话照旧加上-inform der,这里不写了) PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.生成pfx的命令类似这样:openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt 其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库. JKS - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了. 证书编码的转换PEM转为DER openssl x509 -in cert.crt -outform der -out cert.der DER转为PEM openssl x509 -in cert.crt -inform der -outform pem -out cert.pem (提示:要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req…) 获得证书向权威证书颁发机构申请证书用这命令生成一个csr: openssl req -newkey rsa:2048 -new -nodes -keyout my.key -out my.csr把csr交给权威证书颁发机构,权威证书颁发机构对此进行签名,完成.保留好csr,当权威证书颁发机构颁发的证书过期的时候,你还可以用同样的csr来申请新的证书,key保持不变. 或者生成自签名的证书openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem在生成证书的过程中会要你填一堆的东西,其实真正要填的只有Common Name,通常填写你服务器的域名,如”yourcompany.com”,或者你服务器的IP地址,其它都可以留空的.生产环境中还是不要使用自签的证书,否则浏览器会不认,或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的,但现在也有免费的,仅仅需要一个简单的域名验证即可.有兴趣的话查查”沃通数字证书”. 源自 https://www.cnblogs.com/guogangj/p/4118605.html","tags":[{"name":"others","slug":"others","permalink":"https://60ke.github.io/tags/others/"}]},{"title":"flask自建证书及测试","date":"2019-12-19T04:08:35.000Z","path":"2019/12/19/flask自建证书及测试/","text":"生成密钥、证书第一步，为服务器端和客户端准备公钥、私钥 生成服务器端私钥openssl genrsa -out server.key 1024 生成服务器端公钥openssl rsa -in server.key -pubout -out server.pem 生成客户端私钥openssl genrsa -out client.key 1024 生成客户端公钥openssl rsa -in client.key -pubout -out client.pem第二步，生成 CA 证书 生成 CA 私钥openssl genrsa -out ca.key 1024 X.509 Certificate Signing Request (CSR) Management.openssl req -new -key ca.key -out ca.csr X.509 Certificate Data Management.openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt在执行第二步时会出现： ➜ keys openssl req -new -key ca.key -out ca.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter ‘.’, the field will be left blank. Country Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:ZhejiangLocality Name (eg, city) []:HangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:My CAOrganizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:localhostEmail Address []:注意，这里的 Organization Name (eg, company) [Internet Widgits Pty Ltd]: 后面生成客户端和服务器端证书的时候也需要填写，不要写成一样的！！！可以随意写如：My CA, My Server, My Client。 然后 Common Name (e.g. server FQDN or YOUR name) []: 这一项，是最后可以访问的域名，我这里为了方便测试，写成 localhost，如果是为了给我的网站生成证书，需要写成 barretlee.com。 第三步，生成服务器端证书和客户端证书 服务器端需要向 CA 机构申请签名证书，在申请签名证书之前依然是创建自己的 CSR 文件openssl req -new -key server.key -out server.csr 向自己的 CA 机构申请证书，签名过程需要 CA 的证书和私钥参与，最终颁发一个带有 CA 签名的证书openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt client 端openssl req -new -key client.key -out client.csr client 端到 CA 签名openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt此时，我们的 keys 文件夹下已经有如下内容了： .├── https-client.js├── https-server.js└── keys├── ca.crt├── ca.csr├── ca.key├── ca.pem├── ca.srl├── client.crt├── client.csr├── client.key├── client.pem├── server.crt├── server.csr├── server.key└── server.pem看到上面两个 js 文件了么，我们来跑几个demo。 HTTPS本地测试服务器代码： // file http-server.jsvar https = require(‘https’);var fs = require(‘fs’); var options = {key: fs.readFileSync(‘./keys/server.key’),cert: fs.readFileSync(‘./keys/server.crt’)}; https.createServer(options, function(req, res) {res.writeHead(200);res.end(‘hello world’);}).listen(8000);短短几行代码就构建了一个简单的 https 服务器，options 将私钥和证书带上。然后利用 curl 测试： ➜ https curl //localhost:8000curl: (60) SSL certificate problem: Invalid certificate chainMore details here: http://curl.haxx.se/docs/sslcerts.html curl performs SSL certificate verification by default, using a “bundle”of Certificate Authority (CA) public keys (CA certs). If the defaultbundle file isn’t adequate, you can specify an alternate fileusing the –cacert option.If this HTTPS server uses a certificate signed by a CA represented inthe bundle, the certificate verification probably failed due to aproblem with the certificate (it might be expired, or the name mightnot match the domain name in the URL).If you’d like to turn off curl’s verification of the certificate, usethe -k (or –insecure) option.当我们直接访问时，curl //localhost:8000 一堆提示，原因是没有经过 CA 认证，添加 -k 参数能够解决这个问题： ➜ https curl -k //localhost:8000hello world%这样的方式是不安全的，存在我们上面提到的中间人攻击问题。可以搞一个客户端带上 CA 证书试试： // file http-client.jsvar https = require(‘https’);var fs = require(‘fs’); var options = {hostname: “localhost”,port: 8000,path: ‘/‘,methed: ‘GET’,key: fs.readFileSync(‘./keys/client.key’),cert: fs.readFileSync(‘./keys/client.crt’),ca: [fs.readFileSync(‘./keys/ca.crt’)]}; options.agent = new https.Agent(options); var req = https.request(options, function(res) {res.setEncoding(‘utf-8’);res.on(‘data’, function(d) {console.log(d);});});req.end(); req.on(‘error’, function(e) {console.log(e);});先打开服务器 node http-server.js，然后执行 ➜ https node https-client.jshello world如果你的代码没有输出 hello world，说明证书生成的时候存在问题。也可以通过浏览器访问： https证书问题 提示错误： 此服务器无法证明它是localhost；您计算机的操作系统不信任其安全证书。出现此问题的原因可能是配置有误或您的连接被拦截了。 原因是浏览器没有 CA 证书，只有 CA 证书，服务器才能够确定，这个用户就是真实的来自 localhost 的访问请求（比如不是代理过来的）。 你可以点击 继续前往localhost（不安全） 这个链接，相当于执行 curl -k //localhost:8000。如果我们的证书不是自己颁发，而是去靠谱的机构去申请的，那就不会出现这样的问题，因为靠谱机构的证书会放到浏览器中，浏览器会帮我们做很多事情。初次尝试的同学可以去 startssl.com 申请一个免费的证书。 Nginx 部署ssh 到你的服务器，对 Nginx 做如下配置： server_names barretlee.com *.barretlee.comssl on;ssl_certificate /etc/nginx/ssl/barretlee.com.crt;ssl_certificate_key /etc/nginx/ssl/barretlee.com.key;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_ciphers “EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !MEDIUM”; Add perfect forward secrecyssl_prefer_server_ciphers on;add_header Strict-Transport-Security “max-age=31536000; includeSubdomains”;会发现，网页 URL 地址框左边已经多出了一个小绿锁。当然，部署好了之后可以去这个网站看看测评分数，如果分数是 A+，说明你的 HTTPS 的各项配置都还不错，速度也很快。 使用CA签名过的证书和私钥导出P12格式个人证书openssl pkcs12 -export -inkey clientkey.pem -in client.crt -out client.p12 启动flask12345678910111213from flask import Flaskapp = Flask(__name__)@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def hello(): return &#x27;hello world&#x27; if __name__ == &#x27;__main__&#x27;: #app.run(host=&#x27;0.0.0.0&#x27;,ssl_context=&#x27;adhoc&#x27;) app.run(host=&#x27;0.0.0.0&#x27;, ssl_context=( &quot;server.crt&quot;, &quot;server.key&quot;)) requests测试1234567import requestsrep = requests.get(&#x27;https://127.0.0.1:5000/&#x27;, cert=(&#x27;/Users/k/Desktop/scp/flask/client/client-cert.pem&#x27;, &#x27;/Users/k/Desktop/scp/flask/client/client-key.pem&#x27;), verify=False)print(rep.text)# rep = requests.get(&#x27;https://127.0.0.1:5000/&#x27;,verify=False)# print(rep.text) 源自：https://www.cnblogs.com/liyulong1982/p/6106129.htmlhttps://blog.csdn.net/yannanxiu/article/details/70670225https://www.jianshu.com/p/5ea147e03255","tags":[{"name":"others","slug":"others","permalink":"https://60ke.github.io/tags/others/"}]},{"title":"rust宏展开","date":"2019-10-10T03:18:04.000Z","path":"2019/10/10/rust宏展开/","text":"2019年10月10日11:22:15 cargo-expand包可对rust进行宏展开，但是这个特性是基于rust的nightly版本的，所以我们首先需要安装nightly版本的rust：Run rustup install nightly安装cargo-expand:cargo install cargo-expand运行：rustup run nightly cargo rustc -- -Z unstable-options --pretty=expanded 对指定rust文件进行展开：RUSTFMT=./sputnikvm/src/eval/run/flow.rs cargo expand","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"openwrt","date":"2019-07-18T09:19:53.000Z","path":"2019/07/18/openwrt/","text":"先刷第三方的不死boot，这个相当于手机刷机的”recovery” https://www.right.com.cn/forum/thread-161906-1-1.html https://www.right.com.cn/forum/thread-341079-1-1.html 路由断电按reset重启进入uboot，刷入openwrt https://openwrt.org/ newifi的openwrt（带支持订阅的ss） 也可以自己编译https://github.com/coolsnowwolf/lede 上面的那个openwrt的软件源使用的是国内镜像现在不能用了，更改软件源为官方的（虽然速度慢但是不会挂） 1234567src/gz openwrt_core http://downloads.openwrt.org/releases/18.06.1/targets/ramips/mt7620/packagessrc/gz openwrt_kmods http://downloads.openwrt.org/releases/18.06.1/targets/ramips/mt7620/kmods/4.14.131-1-f908844d5e5aab0a4b27f7d4c77655d0src/gz openwrt_base http://downloads.openwrt.org/releases/18.06.1/packages/mipsel_24kc/basesrc/gz openwrt_luci http://downloads.openwrt.org/releases/18.06.1/packages/mipsel_24kc/lucisrc/gz openwrt_packages http://downloads.openwrt.org/releases/18.06.1/packages/mipsel_24kc/packagessrc/gz openwrt_routing http://downloads.openwrt.org/releases/18.06.1/packages/mipsel_24kc/routingsrc/gz openwrt_telephony http://downloads.openwrt.org/releases/18.06.1/packages/mipsel_24kc/telephony","tags":[{"name":"路由器","slug":"路由器","permalink":"https://60ke.github.io/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/"}]},{"title":"MySQL","date":"2019-07-10T03:20:46.000Z","path":"2019/07/10/MySQL/","text":"MySQL5.7.22数据库安装完后更改密码； ALTER USER USER() IDENTIFIED BY &#39;12345678&#39;;","tags":[{"name":"mysql","slug":"mysql","permalink":"https://60ke.github.io/tags/mysql/"}]},{"title":"rust学习02","date":"2019-06-19T01:50:21.000Z","path":"2019/06/19/rust学习02/","text":"cargo 安装指定版本： 1cargo install --version 2.0.13 racer 新建 vector为了创建一个新的空 vector，可以调用 Vec::new 函数，如示例 8-1 所示： 1let v: Vec&lt;i32&gt; = Vec::new(); 示例 8-1：新建一个空的 vector 来储存 i32 类型的值 注意这里我们增加了一个类型注解。因为没有向这个 vector 中插入任何值，Rust 并不知道我们想要储存什么类型的元素。这是一个非常重要的点。vector 是用泛型实现的，第十章会涉及到如何对你自己的类型使用它们。现在，所有你需要知道的就是 Vec 是一个由标准库提供的类型，它可以存放任何类型，而当 Vec 存放某个特定类型时，那个类型位于尖括号中。在示例 8-1 中，我们告诉 Rust v 这个 Vec 将存放 i32 类型的元素。 Rust通过impl关键字在struct、enum或者trait对象上实现方法调用语法 (method call syntax)。 关联函数 (associated function) 的第一个参数通常为self参数，有3种变体 self，允许实现者移动和修改对象，对应的闭包特性为FnOnce。 &amp;self，既不允许实现者移动对象也不允许修改，对应的闭包特性为Fn。 &amp;mut self，允许实现者修改对象但不允许移动，对应的闭包特性为FnMut。 三个在 Rust 程序中被广泛使用的集合： vector 允许我们一个挨着一个地储存一系列数量可变的值 字符串（string）是一个字符的集合。我们之前见过 String 类型，不过在本章我们将深入了解。 哈希 map（hash map）允许我们将值与一个特定的键（key）相关联。这是一个叫做 map 的更通用的数据结构的特定实现。 新的空 vector: 1let v: Vec&lt;i32&gt; = Vec::new(); 使用rust宏vec!来创建一个新的Vec，vec宏能够根据插入的值来推断要存放的类型。 1let v = vec![1, 2, 3]; 为了参数化要定义的函数的签名中的类型，我们需要像给函数的值参数起名那样为这类型参数起一个名字。任何标识符都可以作为类型参数名。不过选择 T 是因为 Rust 的习惯是让变量名尽量短，通常就只有一个字母，同时 Rust 类型命名规范是骆驼命名法（CamelCase）。T 作为 “type” 的缩写是大部分 Rust 程序员的首选。 当需要在函数体中使用一个参数时，必须在函数签名中声明这个参数以便编译器能知道函数体中这个名称的意义。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。，类型参数声明位于函数名称与参数列表中间的尖括号 &lt;&gt; 。 rust 关键字 https://doc.rust-lang.org/book/appendix-01-keywords.html 个人觉得rust里面的单引号：有解释进一步说明的意思，跟随在变量后面。 名字以叹号结尾， 并且可以像函数一样被调用的语句， 在 Rust中叫作宏。 “Rust里面的下划线是一个特殊的标识符，在编译器内部它是被特殊处理的。”","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"rust学习01","date":"2019-06-06T07:24:14.000Z","path":"2019/06/06/rust学习01/","text":"rust在线中文教程：https://kaisery.github.io/trpl-zh-cn rust猜数字游戏： 12345678910111213141516171819202122232425262728293031323334use std::io;use std::cmp::Ordering;use rand::Rng;use std::time::Duration;use std::thread::sleep;fn main()&#123; println!(&quot;Guess the number!&quot;); let secret_number = rand::thread_rng().gen_range(1,101); // println!(&quot;The secret number is :&#123;&#125;&quot;,secret_number); loop &#123; println!(&quot;Please input your guess&quot;); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;); let guess: u32 = match guess.trim().parse()&#123; Ok(num) =&gt; num, Err(_) =&gt; &#123; println!(&quot;Please input a number!&quot;); continue; &#125; &#125;; println!(&quot;You guessed: &#123;&#125;&quot;,guess); match guess.cmp(&amp;secret_number)&#123; Ordering::Less =&gt; println!(&quot;Too small&quot;), Ordering::Greater =&gt; println!(&quot;Too big&quot;), Ordering::Equal =&gt; &#123; println!(&quot;You win!&quot;); sleep(Duration::from_secs(4));//为了展示效果，防止Windows下运行完程序直接退出 break; &#125; &#125; &#125;&#125; 注意： 1.。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 return 关键字和指定值，可从函数中提前返回；但大部分函数隐式的返回最后的表达式。","tags":[{"name":"rust","slug":"rust","permalink":"https://60ke.github.io/tags/rust/"}]},{"title":"从typecho迁移到hexo","date":"2019-05-31T03:14:21.000Z","path":"2019/05/31/从typecho迁移到hexo/","text":"vps翻墙用的也不多而且延迟比较高，以前总是因为typecho上的博客所以一直断断续续的在用，现在把typecho的博客在mysql中的文章导出为markdown格式从而迁移到hexo。 下面是代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding: utf-8 -*-import codecsimport osimport torndbimport arrowimport sysreload(sys)sys.setdefaultencoding(&#x27;utf-8&#x27;)def create_data(db): # 创建分类和标签 categories = db.query(&quot;select type, slug, name from typecho_metas&quot;) for cate in categories: path = &#x27;data/%s&#x27; % cate.slug if not os.path.exists(path): os.makedirs(path) f = codecs.open(&#x27;%s/index.md&#x27; % path, &#x27;w&#x27;, &quot;utf-8&quot;) f.write(&quot;title: %s\\n&quot; % cate.slug) f.write(&quot;date: %s\\n&quot; % arrow.now().format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) # 区分分类和标签 if cate.type == &#x27;category&#x27;: f.write(&#x27;type: &quot;categories&quot;\\n&#x27;) elif cate.type == &#x27;tags&#x27;: f.write(&#x27;type: &quot;tags&quot;\\n&#x27;) # 禁止评论 f.write(&quot;comments: true\\n&quot;) f.write(&quot;---\\n&quot;) f.close() # 创建文章 entries = db.query(&quot;select cid, title, slug, text, created from typecho_contents where type=&#x27;post&#x27;&quot;) for e in entries: title = e.title urlname = e.slug print(title) content = str(e.text).replace(&#x27;&lt;!--markdown--&gt;&#x27;, &#x27;&#x27;) tags = [] category = &quot;&quot; # 找出文章的tag及category metas = db.query( &quot;select type, name, slug from `typecho_relationships` ts, typecho_metas tm where tm.mid = ts.mid and ts.cid = %s&quot;, e.cid) for m in metas: if m.type == &#x27;tag&#x27;: tags.append(m.name) if m.type == &#x27;category&#x27;: category = m.slug path = &#x27;data/_posts/&#x27; if not os.path.exists(path): os.makedirs(path) f = codecs.open(r&quot;%s%s.md&quot; % (path,title), &#x27;w+&#x27;, &quot;utf-8&quot;) f.write(&quot;---\\n&quot;) f.write(&quot;title: %s\\n&quot; % title) f.write(&quot;date: %s\\n&quot; % arrow.get(e.created).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)) f.write(&quot;categories: %s\\n&quot; % category) f.write(&quot;tags: [%s]\\n&quot; % &#x27;,&#x27;.join(tags)) f.write(&quot;urlname: %s\\n&quot; % urlname) f.write(&quot;---\\n&quot;) #:import pdb; pdb.set_trace() f.write(content) f.close()def main(): # 把数据库连接信息 db = torndb.Connection(host=&quot;&quot;, database=&quot;typecho&quot;, user=&quot;root&quot;, password=&quot;&quot;) create_data(db)if __name__ == &quot;__main__&quot;: main()","tags":[]},{"title":"mac下的Python2的mysql模块","date":"2019-05-30T07:53:33.000Z","path":"2019/05/30/mac下的Python2的mysql模块/","text":"mac下的Python2的mysql模块1234567brew install mysqlbrew unlink mysqlbrew install mysql-connector-csed -i -e &#x27;s/libs=&quot;$libs -l &quot;/libs=&quot;$libs -lmysqlclient -lssl -lcrypto&quot;/g&#x27; /usr/local/bin/mysql_configpip install MySQL-pythonbrew unlink mysql-connector-cbrew link --overwrite mysql brew unlink mysql # only if installed, causes the next step to fail brew install mysql-connector-c locate mysql_config file with which (mysql_config) edit the mysql_config file, under # Create options change this: libs=&quot;$libs -l &quot; to this: libs=&quot;$libs -lmysqlclient -lssl -lcrypto&quot; if using vim, :wq! to save the read-only file Now the install should run successfully pip install mysqlclient Adding this separately, as it’s similar but not directly related to the initial question pip install MySQL-python Fix mysql brew formula, if it was unlinked in the first step. brew unlink mysql-connector-c brew link mysql","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"},{"name":"mac","slug":"mac","permalink":"https://60ke.github.io/tags/mac/"}]},{"title":"homebrew 安装mysql","date":"2019-05-29T17:53:33.000Z","path":"2019/05/30/homebrew 安装mysql/","text":"homebrew 安装mysql 安装mysql brew install mysql 启动mysql服务 mysql.server start 设置mysql(密码等) mysql_secure_installation","tags":[{"name":"mac","slug":"mac","permalink":"https://60ke.github.io/tags/mac/"}]},{"title":"paramiko 执行sudo","date":"2019-05-28T04:00:26.000Z","path":"2019/05/28/paramiko-执行sudo/","text":"1234567891011import paramikossh = paramiko.SSHClient() ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())host_ips = &quot;127.0.0.1&quot;username = &quot;admin&quot;password = &quot;admin&quot;port = 22ssh.connect(host_ip,port,username,password)stdin, stdout, stderr = ssh.exec_command(&quot;sudo -S -p &#x27;&#x27; service redis restart;&quot;)#stdout.read()可以获取输出内容 注意执行带有 sudo的 ssh.exec_command()时需要在命令前加 sudo -S -p &#39;&#39;","tags":[]},{"title":"小可爱学Python01","date":"2019-05-27T09:07:48.000Z","path":"2019/05/27/小可爱学Python01/","text":"关于Python这门语言网上很多啰啰嗦嗦的一大堆。虽然小可爱你对它还不太了解，不过我并不打算跟你扯这些。（😀）编程能做的事情很多，我找了一个简单对你还算有趣的来作为示例，你可能不是很理解，但是带着兴趣和疑问才会有继续下去的想法。这篇文章作为小可爱入门Python的第一篇，一共分为两大部分。 安装Python 使用Python获取表情包 安装Python下载最新版本的Python安装包https://www.python.org/ftp/python/3.7.3/python-3.7.3-amd64.exe 然后像安装软件一样正常安装就行了，但是特别注意有个地方需要打钩（默认是不打勾的） 你看到的应该是Python3.7。 安装完成之后此时你的电脑就能用Python了。","tags":[]},{"title":"你好呀，小可爱！","date":"2019-04-02T00:55:04.000Z","path":"2019/04/02/你好呀，小可爱！/","text":"你好呀，小可爱！","tags":[]},{"title":"python中文文档阅读笔记","date":"2019-04-01T23:46:00.000Z","path":"2019/04/02/python中文文档阅读笔记/","text":"当在序列中循环时，用 enumerate() 函数可以将索引位置和其对应的值同时取出 1234567&gt;&gt;&gt;&gt;&gt;&gt; for i, v in enumerate([&#x27;tic&#x27;, &#x27;tac&#x27;, &#x27;toe&#x27;]):... print(i, v)...0 tic1 tac2 toe 5.1.2. 列表作为队列使用¶列表也可以用作队列，其中先添加的元素被最先取出 (“先进先出”)；然而列表用作这个目的相当低效。因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹出元素却很慢 (因为所有的其他元素都必须移动一位)。 若要实现一个队列， collections.deque 被设计用于快速地从两端操作。例如 1234567891011&gt;&gt;&gt;&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; queue = deque([&quot;Eric&quot;, &quot;John&quot;, &quot;Michael&quot;])&gt;&gt;&gt; queue.append(&quot;Terry&quot;) # Terry arrives&gt;&gt;&gt; queue.append(&quot;Graham&quot;) # Graham arrives&gt;&gt;&gt; queue.popleft() # The first to arrive now leaves&#x27;Eric&#x27;&gt;&gt;&gt; queue.popleft() # The second to arrive now leaves&#x27;John&#x27;&gt;&gt;&gt; queue # Remaining queue in order of arrivaldeque([&#x27;Michael&#x27;, &#x27;Terry&#x27;, &#x27;Graham&#x27;]) 比较操作可以传递。例如 a &lt; b == c 会校验是否 a 小于 b 并且 b 等于 c。 花括号或 set() 函数可以用来创建集合。注意：要创建一个空集合你只能用 set() 而不能用 {}，因为后者是创建一个空字典，这种数据结构我们会在下一节进行讨论。 以下是一些简单的示例： 1234567891011121314151617181920212223242526272829&gt;&gt;&gt;&gt;&gt;&gt; basket = &#123;&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;apple&#x27;, &#x27;pear&#x27;, &#x27;orange&#x27;, &#x27;banana&#x27;&#125;&gt;&gt;&gt; print(basket) # show that duplicates have been removed&#123;&#x27;orange&#x27;, &#x27;banana&#x27;, &#x27;pear&#x27;, &#x27;apple&#x27;&#125;&gt;&gt;&gt; &#x27;orange&#x27; in basket # fast membership testingTrue&gt;&gt;&gt; &#x27;crabgrass&#x27; in basketFalse&gt;&gt;&gt; # Demonstrate set operations on unique letters from two words...&gt;&gt;&gt; a = set(&#x27;abracadabra&#x27;)&gt;&gt;&gt; b = set(&#x27;alacazam&#x27;)&gt;&gt;&gt; a # unique letters in a&#123;&#x27;a&#x27;, &#x27;r&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;&gt;&gt;&gt; a - b # letters in a but not in b&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;&#125;&gt;&gt;&gt; a | b # letters in a or b or both&#123;&#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;&gt;&gt;&gt; a &amp; b # letters in both a and b&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;&gt;&gt;&gt; a ^ b # letters in a or b but not both&#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;m&#x27;, &#x27;z&#x27;, &#x27;l&#x27;&#125;类似于 列表推导式，集合也支持推导式形式&gt;&gt;&gt;&gt;&gt;&gt; a = &#123;x for x in &#x27;abracadabra&#x27; if x not in &#x27;abc&#x27;&#125;&gt;&gt;&gt; a&#123;&#x27;r&#x27;, &#x27;d&#x27;&#125; 布尔运算符 and 和 or 也被成为 短路 运算符：它们的参数从左至右解析，一旦可以确定结果解析就会停止。例如，如果 A 和 C 为真而 B 为假，那么 A and B and C 不会解析 C。当作用于普通值而非布尔值时，短路操作符的返回值通常是最后一个变量。 12345678910&gt;&gt;&gt; string1, string2, string3 = &#x27;&#x27;, &#x27;Trondheim&#x27;, &#x27;Hammer Dance&#x27;&gt;&gt;&gt; string1 or string2&#x27;Trondheim&#x27;&gt;&gt;&gt; string3 or string2&#x27;Hammer Dance&#x27;&gt;&gt;&gt; string2 or string3&#x27;Trondheim&#x27;&gt;&gt;&gt; string1 or string2 or string3&#x27;Trondheim&#x27;&gt;&gt;&gt; 格式化字符串字面值 （常简称为 f-字符串）能让你在字符串前加上 f 和 F 并将表达式写成 {expression} 来在字符串中包含 Python 表达式的值。 可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示例将pi舍入到小数点后三位: 1234&gt;&gt;&gt;&gt;&gt;&gt; import math&gt;&gt;&gt; print(f&#x27;The value of pi is approximately &#123;math.pi:.3f&#125;.&#x27;)The value of pi is approximately 3.142. 在 ‘:’ 后传递一个整数可以让该字段成为最小字符宽度。这在使列对齐时很有用。: 12345678&gt;&gt;&gt;&gt;&gt;&gt; table = &#123;&#x27;Sjoerd&#x27;: 4127, &#x27;Jack&#x27;: 4098, &#x27;Dcab&#x27;: 7678&#125;&gt;&gt;&gt; for name, phone in table.items():... print(f&#x27;&#123;name:10&#125; ==&gt; &#123;phone:10d&#125;&#x27;)...Sjoerd ==&gt; 4127Jack ==&gt; 4098Dcab ==&gt; 7678 其他的修饰符可用于在格式化之前转化值。 ‘!a’ 应用 ascii() ，’!s’ 应用 str()，还有 ‘!r’ 应用 repr(): 123456&gt;&gt;&gt;&gt;&gt;&gt; animals = &#x27;eels&#x27;&gt;&gt;&gt; print(f&#x27;My hovercraft is full of &#123;animals&#125;.&#x27;)My hovercraft is full of eels.&gt;&gt;&gt; print(f&#x27;My hovercraft is full of &#123;animals!r&#125;.&#x27;)My hovercraft is full of &#x27;eels&#x27;.","tags":[]},{"title":"iterm2","date":"2018-12-13T06:07:00.000Z","path":"2018/12/13/iterm2/","text":"iterm2的美化 https://www.cnblogs.com/soyxiaobi/p/9695931.html iterm2实现上传下载安装lrzszbrew install lrzsz 下载zmoden脚本在https://github.com/mmastrac/iterm2-zmodem上将iterm2-send-zmodem.sh 和 iterm2-recv-zmodem.sh脚本下载下来并放到/usr/local/bin/目录下，注意赋予脚本执行的权限 配置iterm2 Trigger打开iterm2 —— 同时按 command和,键 —–》 Profiles ——》 Default —–》 Advanced —–》 Triggers的Edit按钮，在弹出的界面配置以下参数 Regular expression:\\*\\*B0100 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-send-zmodem.sh Regular expression:\\*\\*B00000000000000 Action: Run Silent Coprocess Parameters: /usr/local/bin/iterm2-recv-zmodem.sh","tags":[]},{"title":"homebrew的安装与卸载","date":"2018-12-13T06:04:54.000Z","path":"2018/12/13/homebrew的安装与卸载/","text":"brew的安装/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; brew的卸载/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; homebrew cask的安装brew tap phinze/homebrew-cask brew install brew-cask homebrew cask的卸载brew install brew-cask 可视化homebrew安装工具brew cask install cakebrew 图形化管理Homebrew安装的服务软件brew tap jimbojsb/launchrocketbrew cask install launchrocket 终端工具brew cask install iterm2//配色https://github.com/mbadolato/iTerm2-Color-Schemes shadowsocks客户端brew cask install shadowsocksx-ng perl升级sudo perl -MCPAN -e &#39;CPAN::Shell-&gt;notest(install =&gt; CPAN::Shell-&gt;r)&#39;","tags":[]},{"title":"努力，觉醒，奋起","date":"2018-11-23T09:55:00.000Z","path":"2018/11/23/努力，觉醒，奋起/","text":"失联了半年的张君，今天一大早给我发来微信。扎眼的两句话： 克仔，你宽裕吗，想借你一点，过年的时候给你。哎。 不方便就算了 微信的上一条消息是十一月三号的时候我发给他的，问我这位老朋友在干啥呢？没回。看到借钱的消息，我又想起两三年前他借我几百块钱（好像是两百我记不清了）。也一直没还，我也没指望他还。因为我知道他没钱，是的他一向没钱。印象中他中间提起过一次还钱的事情。那时候他和女朋友关系不融洽怕是要吹了，他可怜巴巴的跟我说：世克，我俩真的分手了我就有钱了，到时候我就可以还你钱了。这几百块钱对我来说没什么影响，我也没指望他还，但是讲道理，我还是挺希望他分的。 张君是从高中开始谈恋爱的，也就是现在的女朋友。姑且称她为小S吧。我和她女朋友,除了来自张君的”杰作” ——12306的火车站联系人，——淘宝的收件人地址，再没什么交集。但是大学室友三年还是知道些关于他们的事情。他们之间的感情细节我知道的十分有限，现在想起来脑海中第一个浮出来的大概就是张君的电话了。张君女友在长沙，而我们在郑州，刚入大学那会，学校的校园网都包给了联通，那时候办一张联通电话卡送100小时的时长，之后每消费一块钱送几个小时(好像是4个，我记不大清了)。我刚入大学就意识到网络的刚需，喊上他我俩每人办了一张。后来没过多久，尽管彼时我手上已经有了比三星i9100配置还高的泛泰a800s。但是为了用200块，得到那部刷机小王子——中兴n880e(自身安卓，但是可以刷windowsphone7，7.5，7.8，现在再说起来还是两眼放光。)签了一个电信的合约，自此宿舍上网的重担就都落到了张君的电话卡之上。张君也不负众望，每月打一百多的电话费，使得我们每月的上网时长超出了30*24小时。当然偶尔他也有没钱打电话的时候，此时我们宿舍也会为了上网对钱给他充话费。张君每个月那漫长的电话和小S说了什么我无从得知,除了他焦躁不安的时候。张君的女朋友经常闹分手，继而将其电话，短信，QQ拉黑（那时候还不怎么玩微信）。每次张君都是一个打不死的小强，不厌其烦的打他女友的电话，或是找他女友的闺蜜。这种事情发生的实在是太多了，我终究忍不住问他：这样一次次的，你都能受得了吗？张君神色黯然：”可能下一次我就受不了了吧，我也到了极限了”。可是我知道下次还有下次。张君在我上铺，早几年我因为失恋的而在他面前眼眶湿润的时候，当他面问他：以前夜深人静的时候，他是不是在床上隐隐啜泣。他没有说话。难以想象一个笑起来像个2b的人也会这样。所以我在基本上对其女友一无所知的情况下，依然留下了不好的印象。 后来又听到张君说起过他和女友之间的故事。一开始张君追的小S，但是小S心里一直有另外一个男生。（是的现实就是这么扯淡）后来张君更是从小S发出的漂流瓶里看到字里行间满满的对那个已经有了女友的男生的情意，和不甘。后来男生结婚，小S哭的痛哭流涕。男生结婚的时候，张君和小S应该已经好了两三年了吧。听到张君说起这个，我愤而问道：这你他妈的都能忍，谈着还有啥劲。张君说道，我一开始也很绝望，可是后来我看到小S的日记。张君和我说了日记的内容，我已经忘记了细节，不过我记得那是小S写的一篇篇关于他的日记。张君觉得小S心里有他。 张君家境当时在我们宿舍应该是最好的了吧，但是小S家境比他好。平日攒钱送礼物都是常事，除了买东西的钱，还得攒去长沙的路费。而他自己的消费，除了电话打得比我们奢侈以外，恐怕吃穿上面他是最省的一个了，即使这样，他依然常年没钱。宿舍除了我还有W君借他的钱他也一直没还。 小S毕业留在了长沙，张君去年毕业也去了长沙。看到微信，我第一时间没回他。一来是我不愿意借钱给借钱不还的人，二来我气他之前没理我，现在借钱想起我来了。 接着我问了W君，果然他也向W借钱了。后来到了中午，张君再次给我打电话，我还是没理他。但是思绪不由的往他身上想。她女朋友家境比他要好，消费水平比他高，他经济肯定有压力。但是我心中认为，他借钱也还不了，除非是遇到什么人命关天的事情，否则我不能再借给他。本想下班再跟他说，可是下午张君又在微信给我发消息，我没忍住，直接把心里想的告诉了他。我说完，他上来就道歉，说自己最近一年出了事，白天上班晚上兼职。还说我发信息的时候是ig夺冠那天(这我倒是没注意),他那时候下班都到十二点了，不知道说啥。后来说晚上再打电话就是和我说说话。我说好。但是心里更加杂乱了。我想不明白他为什么需要兼职，一个没结婚的人，压力这么大。我觉得肯定是他们感情出了问题。 晚上张君跟我打了电话，说起他的最近经历。码农的工作因为经常出差辞职了，找工作找了大半年，中间和他女友一块玩（费用应该是AA）的时候借了网贷（1500，7天之后还2000的那种），后来网贷越滚越多，他又以贷还贷。最多的时候竟然欠了五六万，后来告诉了家里的一部分状况，家里帮他还了，但是他没敢说完。我说你是糊涂啊，网贷利息那么高你也借。打电话的时候他还在兼职，唉。我内心是怒其不争，哀其不幸。当时电话里我没借给他，我说知道他借了也没法还，只要他不是到了万不得已的情况我不借他。 可是挂完电话，我还是放心不下，我同情他，可怜他。同时他也是我的好朋友，到现在我想起当初因为失恋，心若死灰的时候，半夜爬到上铺非要拉着他说话，还是心里一暖。我在想他真实的情况会不会比电话里还要糟糕，我在想他半年都没开口，到现在开口应该就是实在没办法了吧。我又想他会不会想不开，会不会陷入绝望，他怀着希望找我、、、 我想了很多，内心不知道如何是好。后来我把问题交给了他。我跟他微信说道：我也不知道你现在的状况你是否给我说完了，你自己决定吧。我可以借给你。我觉得，是你真到万不得已的时候再说，但是。是不是这情况你自己看吧。你要是真的非常非常非常需要的话。我把钱给你打过去 。 张君收到信息又是开始道歉，说了很多。话里有这么一句：这几天看着那网上的给我打电话，同学给我要钱，父母觉得我没事了，女朋友的冷战，路过大桥，想跳下去是不是就什么事都没有了。我骂他傻逼，多大的事。后来又聊了许久，他说要先坚持着熬过去，把钱还了。我说他真到了想不开的时候，可以找我。他又是抱歉又是感谢的，我说不用，毕竟我也曾爬床烦过他好多次 但是现在想想，这怕是他人生最无助的时候了吧，我很庆幸自己挂完电话又发了微信，我甚至在想自己如果是富二代就好了，我就可以直接把钱给他还上。我再次觉得自己力量渺小，现在是遇到的是朋友，以后可能会是家人，我不想遇到这些事情只是劝他们有个好心态，我想直接把问题给他们解决了。自己一直觉得要做一个有趣的人，一直觉得一个人不能只为别人活着，一直希望父母可以自私一点为他们自己多着想一点。现在想想自己的想法不负责任而又自私，我想变得更强，成为朋友亲人的依靠仰仗，我想这样的人生，为别人的人生要比一个单一的有趣的人更有趣，更有意义。我深知自己是个缺乏毅力的人，写下来希望可以提醒自己。 努力努力再努力！！！","tags":[]},{"title":"mac彻底删除launchpad中的图标","date":"2018-09-14T00:52:00.000Z","path":"2018/09/14/mac彻底删除launchpad中的图标/","text":"之前因为wifi的问题装了许多从网络上面下载的dmg软件，之后发现有些软件在卸载之后图标依然存在于启动台，下面是解决办法。 第一步：找到com.apple.dock.launchpad文件夹：打开一个folder，按command+shift+G，在前往当中输入地址/private/var/folders，然后在里边自己尝试找到com.apple.dock.launchpad这个文件夹，我的路径是，省略号处应该大家都不一样，所以慢慢找，总之最后找到名为com.apple.dock.launchpad的文件夹。 第二步：找到数据库，获取其路径：打开com.apple.dock.launchpad 文件夹 之后有一个db文件夹，再点进去有一个文件叫db,它就是我们要找的数据库。 第三步：开始对数据库进行操作打开终端：cd到刚才拷贝的路径然后输入：sqlite3 db &quot;delete from apps where title=&#39;应用名称&#39;;&quot;&amp;&amp;killall Dock 注意要将应用名称处替换成你要删除的图标的名称，然后回车即可","tags":[]},{"title":"requests中遇到的一些问题","date":"2018-08-01T02:54:00.000Z","path":"2018/08/01/requests中遇到的一些问题/","text":"今天使用Python的requests模拟posts时总是，无法获取到正确的结果，后来使用postman的时候，在发送请求的时候在body中奖数据类型由默认的Text改为json可以成功，但是使用postman生成的python代码，并加入了正确的cookie还是不能获得正常的返回结果。检查代码，在headers中已经添加了&#39;content-type&#39;: &quot;application/json&quot;，但是根据代码返回的异常判断还是发送的数据有问题，最后的解决办法是，在post数据的时候，直接data=json.dumps(data),之后代码正常，这样可以判断出，服务端直接接受的json在python中其实为形如dict的字符串。最后放上代码： 123456789import requests,jsonurl = &quot;http://172.31.1.31/api/realtime_news&quot;data = json.dumps(&#123;&quot;begin&quot;:&quot;2017-01-01 00:00:00&quot;,&quot;end&quot;:&quot;&quot;,&quot;size&quot;:&quot;10&quot;,&quot;offset&quot;:&quot;0&quot;,&quot;data&quot;:&#123;&quot;keyword&quot;:[],&quot;keyword_any&quot;:[],&quot;keyword_not&quot;:[],&quot;emotion&quot;:[&quot;负面&quot;],&quot;media_type&quot;:[&quot;print_media&quot;],&quot;location&quot;:[]&#125;&#125;)cookies = &#123;&quot;token&quot;:&quot;dcd709fe-956e-11e8-9eda-001a4a16015c&quot;,&quot;user_id&quot;:&quot;12&quot;,&quot;username1&quot;:&quot;liushike&quot;&#125;headers = &#123;&quot;Accept&quot;: &quot;application/json, text/javascript, */*; q=0.01&quot;,&quot;Content-Type&quot;: &quot;application/json&quot;,&quot;Connection&quot;: &quot;keep-alive&quot;,&#125;print(type(data))print(json.loads(requests.post(url,headers=headers,data=data,cookies=cookies).text)) requests的params参数构造1234params = ( (&#x27;devid&#x27;, &#x27;99000939663350&#x27;),)response = requests.post(&#x27;https://r.cnews.qq.com/getSubNewsChlidInterest&#x27;, headers=headers, params=params, data=data) 1234567891011等同于：from urllib.parse import urlencodeparams = ( (&#x27;devid&#x27;, &#x27;99000939663350&#x27;),)tar = urlencode(params)print(tar)&#x27;devid=99000939663350&#x27;#进而构造出 https://r.cnews.qq.com/getSubNewsChlidInterest?devid=99000939663350requests.post(&#x27;https://r.cnews.qq.com/getSubNewsChlidInterest?devid=99000939663350&#x27;, headers=headers, data=data)","tags":[]},{"title":"deepin 使用","date":"2018-07-17T23:58:26.000Z","path":"2018/07/18/deepin 使用/","text":"Ubuntu下的文件管理器为 nautilusdeepin的是 dde-file-manager","tags":[]},{"title":"python fromat保留｛｝","date":"2018-07-12T19:41:14.000Z","path":"2018/07/13/python fromat保留｛｝/","text":"今天写程序执行 12cmd = &quot;ps -ef|grep &#123;&#125;|awk \\&#x27;&#123;print $2&#125;\\&#x27;|xargs kill -9&quot;cmd.format(11) 结果报错： 123Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &#x27;print $2&#x27; 正确的写法： 12cmd = &quot;ps -ef|grep &#123;&#125;|awk \\&#x27;&#123;&#123;print $2&#125;&#125;\\&#x27;|xargs kill -9&quot;cmd.format(11)","tags":[]},{"title":"test","date":"2018-07-06T08:44:00.000Z","path":"2018/07/06/test/","text":"12345678st&#x3D;&gt;start: 用户登陆op&#x3D;&gt;operation: 登陆操作cond&#x3D;&gt;condition: 登陆成功 Yes or No?e&#x3D;&gt;end: 进入后台st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op","tags":[]},{"title":"centos安装python3","date":"2018-07-06T02:29:00.000Z","path":"2018/07/06/centos安装python3/","text":"每次虚拟机的centos装python3的时候都百度，打算自己记一下了centos官方的yum源里面有个python34可以使用sudo yum install python34来进行安装，但是我最近在清华源下载的最小版本的centos镜像包href没有python34，python2-pip,运行yum provides ifconfig的命令也不好使。。。，这个暂时也没心思细究了，自己动手丰衣足食,还是编译安装吧！ 下载编译安装包 https://www.python.org/ftp/python python官网的ftp这里你可以找各种版本，当前时间2018-07-06 18:00:51官网最新版本为python3.7，然后下载编译出错了，错误代码No module named &#39;_ctypes&#39;然后查了一下，发现有说曾经别的版本出现过这个问题，然后官方修复之类的。。。,算了我还是稳妥的下了个python3.5，官网提供的压缩包有tgz，tgz.xz的，tgz.xz压缩率更高更小。 wget https://www.python.org/ftp/python/3.5.5/Python-3.5.5.tgz.xz tar -xvJf Python-3.5.5.tgz cd Python-3.5.5 安装编译python3所需要的依赖 yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 话说输入history查看历史命令的时候发现没有记录，然后 cat /etc/profile|grep HIS看到设置的size为1000（玛德难受）继续python3安装 make make install ./configure --prefix=/usr/local/python3 ln -s /usr/local/python3/bin/python3 /usr/bin/python ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 python3的安装完成了，这时候也已经有pip3的命令了。然后pip命令，手动安装一下下载这个： wget https://bootstrap.pypa.io/get-pip.py python(python3) get-pip.py 好了。。。","tags":[]},{"title":"gitlab与github共存","date":"2018-07-05T02:02:20.000Z","path":"2018/07/05/gitlab与github共存/","text":"gitlab与github共存 生成公私匙 ssh-keygen -t rsa -C &quot;邮箱地址&quot;因为生成的时候有个默认的名字，所以注意修改名字使其共存 添加公匙登录gitlab或者github，添加公匙 在.ssh文件下配置config（重点！！！）vim config Host git.goldeneye.org.cn HostName git.goldeneye.org.cn User git IdentityFile /c/Users/i5051/.ssh/gitlab Host github.com HostName github.com User git IdentityFile /c/Users/i5051/.ssh/github","tags":[]},{"title":"微博搜索爬虫","date":"2018-07-05T00:18:46.000Z","path":"2018/07/05/微博搜索爬虫/","text":"爬虫包括了登录，验证码验证模块代码放到github上了微博搜索爬虫","tags":[]},{"title":"解决lnmp上的typecho的404","date":"2018-07-04T08:27:49.000Z","path":"2018/07/04/解决lnmp上的typecho的404/","text":"进入nginx配置/usr/local/nginx/conf/vhost将include enable-php.conf替换为include enable-php-pathinfo.conf","tags":[{"name":"blog","slug":"blog","permalink":"https://60ke.github.io/tags/blog/"}]},{"title":"python操作word","date":"2018-02-26T01:21:51.000Z","path":"2018/02/26/python操作word/","text":"使用python-docx生成Word文档首先安装python-docx： pip install python-docx 例子： from docx import Document from docx.shared import Pt from docx.oxml.ns import qn from docx.shared import Inches #打开文档 document = Document() #加入不同等级的标题 document.add_heading(&#39;Document Title&#39;,0) document.add_heading(u&#39;二级标题&#39;,1) document.add_heading(u&#39;二级标题&#39;,2) #添加文本 paragraph = document.add_paragraph(u&#39;添加了文本&#39;) #设置字号 run = paragraph.add_run(u&#39;设置字号&#39;) run.font.size=Pt(24) #设置字体 run = paragraph.add_run(&#39;Set Font,&#39;) run.font.name=&#39;Consolas&#39; #设置中文字体 run = paragraph.add_run(u&#39;设置中文字体，&#39;) run.font.name=u&#39;宋体&#39; r = run._element r.rPr.rFonts.set(qn(&#39;w:eastAsia&#39;), u&#39;宋体&#39;) #设置斜体 run = paragraph.add_run(u&#39;斜体、&#39;) run.italic = True #设置粗体 run = paragraph.add_run(u&#39;粗体&#39;).bold = True #增加引用 document.add_paragraph(&#39;Intense quote&#39;, style=&#39;Intense Quote&#39;) #增加有序列表 document.add_paragraph( u&#39;有序列表元素1&#39;,style=&#39;List Number&#39; ) document.add_paragraph( u&#39;有序列别元素2&#39;,style=&#39;List Number&#39; ) #增加无序列表 document.add_paragraph( u&#39;无序列表元素1&#39;,style=&#39;List Bullet&#39; ) document.add_paragraph( u&#39;无序列表元素2&#39;,style=&#39;List Bullet&#39; ) #增加图片（此处使用相对位置） document.add_picture(&#39;jdb.jpg&#39;,width=Inches(1.25)) #增加表格 table = document.add_table(rows=3,cols=3) hdr_cells=table.rows[0].cells hdr_cells[0].text=&quot;第一列&quot; hdr_cells[1].text=&quot;第二列&quot; hdr_cells[2].text=&quot;第三列&quot; hdr_cells = table.rows[1].cells hdr_cells[0].text = &#39;2&#39; hdr_cells[1].text = &#39;aerszvfdgx&#39; hdr_cells[2].text = &#39;abdzfgxfdf&#39; hdr_cells = table.rows[2].cells hdr_cells[0].text = &#39;3&#39; hdr_cells[1].text = &#39;cafdwvaef&#39; hdr_cells[2].text = &#39;aabs zfgf&#39; #增加分页 document.add_page_break() #保存文件 document.save(&#39;demo.docx&#39;) 效果： 打开及保存文件： from docx import Document document = Document(&#39;test.docx&#39;) document.save(&#39;test.docx&#39;) 添加文本： document.add_paragraph(&#39;test text&#39;) 调整文本位置格式为居中： from docx import Document from docx.enum.text import WD_ALIGN_PARAGRAPH document = Document(&#39;test.docx&#39;) paragraph = document.add_paragraph(&#39;123&#39;) paragraph.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER document.save(&#39;test.docx&#39;) 调整左缩进0.3英寸： document = Document(&#39;test.docx&#39;) paragraph = document.add_paragraph(&#39;this is test for left_indent with inches&#39;) paragraph_format = paragraph.paragraph_format paragraph_format.left_indent = Inches(0.3) document.save(&#39;test.docx&#39;) 首行缩进： paragraph_format.first_line_indent = Inches(0.3) 上行间距： paragraph_format.space_before = Pt(18) 下行间距： paragraph_format.space_after = Pt(12) 行距： paragraph_format.line_spacing = Pt(18) 分页格式：紧跟上段： paragraph_format.keep_together 若本页无法完全显示，另起一页： paragraph_format.keep_with_next 强制另起一页： paragraph_format.page_break_before 字体格式： &lt;pre name=&quot;code&quot; class=&quot;python&quot;&gt;p = document.add_paragraph() run = p.add_run(&#39;test typeface&#39;) #加粗 run.font.bold = True #斜体 run.font.italic = True #下划线 run.font.underline = True WD_UNDERLINE 中有所有下划线格式 调用样例： run.underline = WD_UNDERLINE.DOT_DASH 字体颜色： from docx.shared import RGBColor test = document.add_paragraph().add_run(&#39;color&#39;) font = test.font font.color.rgb = RGBColor(0x42, 0x24 , 0xE9) 调用预设颜色： from docx.enum.dml import MSO_THEME_COLOR font.color.theme_color = MSO_THEME_COLOR.ACCENT_1 参考连接：http://blog.csdn.net/u011932355/article/details/51769803https://www.jianshu.com/p/1f60cdd9655a","tags":[]},{"title":"scrapy之FormRequest模拟post请求","date":"2018-01-01T23:36:19.000Z","path":"2018/01/02/scrapy之FormRequest模拟post请求/","text":"先放代码吧，以后闲了再完善 def start_requests(self): url = &quot;http://www.hebzx.gov.cn/specialnews.aspx?meetingtype=009001&quot; yield scrapy.Request(url,callback=self.parse0) def parse0(self,response): formdata = &#123;&quot;__EVENTTARGET&quot;:&quot;AspNetPager1&quot;,&quot;__EVENTARGUMENT&quot;:&quot;2&quot;&#125; return scrapy.FormRequest.from_response( response, formdata=formdata, callback=self.parse1 ) def parse1(self,response): print(&quot;1111111111111&quot;) print(response.text)","tags":[]},{"title":"sublime sftp 插件安装及破解","date":"2017-11-28T19:17:00.000Z","path":"2017/11/29/sublime sftp 插件安装及破解/","text":"每次装完系统都需要重新安装配置sublime+python的环境，这次写个文章记一下。 1.python配置在![](http://ww1.sinaimg.cn/large/6cf740f6ly1flyr6qgoj1j211y0lcjv9.jpg这里可以创建新的环境配置 linux(ubuntu)： python3.sublime-build配置： &#123; &quot;cmd&quot;: [&quot;/usr/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot; &#125; windows： 保存的目录在C:\\Users\\i5051\\AppData\\Roaming\\Sublime Text 3\\Packages\\User里面python3.sublime-build配置： &#123; &quot;cmd&quot;: [&quot;XXXXXXXXXX&quot;,&quot;-u&quot;,&quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot;, &#125; “””“XXXXXXXXXX”用python.exe的全路径代替“”” mac： 路径：/Users/ke/Library/Application Support/Sublime Text 3/Packagespython3.sublime-build配置： &#123; &quot;cmd&quot;: [&quot;/usr/local/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;], &quot;file_regex&quot;: &quot;^[ ]*File \\&quot;(...*?)\\&quot;, line ([0-9]*)&quot;, &quot;selector&quot;: &quot;source.python&quot; &#125; 2.必备插件 SublimeTmpl：可以自定义新建文件模板 python模板配置，在setting-user中设置： &#123; &quot;attr&quot;: &#123; &quot;author&quot;: &quot;60ke&quot;, &quot;email&quot;: &quot;worileqing@163.com&quot;, &quot;link&quot;: &quot;http://www.worileqing.top&quot;, &quot;version&quot;: &quot;python3&quot; &#125;, &quot;date_format&quot;: &quot;%Y-%m-%d %H:%M:%S&quot; &#125; 快捷键设置，在key—bingding中设置： [ &#123; &quot;caption&quot;: &quot;Tmpl: Create python&quot;, &quot;command&quot;: &quot;sublime_tmpl&quot;, &quot;keys&quot;: [&quot;ctrl+alt+p&quot;], &quot;args&quot;: &#123;&quot;type&quot;: &quot;python&quot;&#125; &#125;, ] Sftp：ssh编辑远程文件必备 部分配置：用sublime打开文件夹，右键文件夹，在sftp的editing remote mapping中编辑设置： &quot;type&quot;: &quot;sftp&quot;, &quot;save_before_upload&quot;: true, &quot;upload_on_save&quot;: true, &quot;sync_down_on_open&quot;: false, &quot;sync_skip_deletes&quot;: false, &quot;sync_same_age&quot;: true, &quot;confirm_downloads&quot;: false, &quot;confirm_sync&quot;: true, &quot;confirm_overwrite_newer&quot;: false, &quot;host&quot;: &quot;10.0.2.30&quot;, &quot;user&quot;: &quot;root&quot;, &quot;password&quot;: &quot;111111&quot;, &quot;port&quot;: &quot;22&quot;, PrettyJson:格式化Json的插件 3.sublime的sftp的插件破解必备插件sftp：1，Package Control可以用来install其他package2，sftp远程编辑文件：安装：install-&gt;sftp具体配置 sftp工具破解 1，下载python字节码反编译工具uncompyle2 (pyc 2 py) https://github.com/wibiti/uncompyle2 2，安装uncompyle2 3，工具安装后的位置 E:\\Python27\\Scripts\\uncompyle2 4，反编译文件commands.pyc python uncompyle2 -o commands.py commands.pyc 5，注释掉函数即可 sublime.set_timeout(reg, 1) PS:sublime的go环境开发可以使用gosublime的插件","tags":[{"name":"sublime","slug":"sublime","permalink":"https://60ke.github.io/tags/sublime/"}]},{"title":"bash问题解决","date":"2017-11-26T04:48:32.000Z","path":"2017/11/26/bash问题解决/","text":"解决 [执行中]http: ../sysdeps/posix/getaddrinfo.c:2603：getaddrinfo: 假设 ‘IN6_IS_ADDR_V4MAPPED (sin6-&gt;sin6_addr.s6_addr32)’ 失败的问题Important Note: Existing Ubuntu 14.04 instances are NOT automatically upgraded to 16.04: You must manually upgrade your instance to Ubuntu 16.04 in one of two ways: Remove &amp; Replace (recommended)Upgrade In-PlaceRemove &amp; replaceIf you’re currently running an Ubuntu 14.04 instance, we recommend removing and replacing your existing instance with a fresh new Ubuntu 16.04 instance. WARNING: The instructions below will delete your existing distro and any of the files you’ve stored in the Linux filesystem. Therefore, be sure to copy/move any Linux files you want to keep, for example, to a Windows folder (e.g. /mnt/c/temp/wslbackup/…) BEFORE removing and replacing your instance! To remove and re-install your Ubuntu instance, run the following commands from a Cmd/PowerShell Console. C:&gt; lxrun /uninstall /full /y…C:&gt; lxrun /installThe lxrun /install command above will then download and install a fresh new copy of Ubuntu 16.04 onto your machine. Upgrade In-PlaceIf your Ubuntu instance is particularly complex to configure, you can opt to upgrade it in-place, though this may not result in an optimal instance. If you opt to upgrade your instance in-place, use Ubuntu’s instructions for upgrading an existing instance: $ sudo do-release-upgrade 具体可参考：https://blogs.msdn.microsoft.com/commandline/2017/04/11/windows-10-creators-update-whats-new-in-bashwsl-windows-console/","tags":[]},{"title":"python模块之difflib字符串，相似度差异比较","date":"2017-11-23T01:18:00.000Z","path":"2017/11/23/python模块之difflib字符串，相似度差异比较/","text":"最近要做redhat的版本比较，本来以为和ubuntu没差多少，之后才发现，redhat的yum源里面只放了一个当前的版本号，比如如果你安装的是vim7，之后vim升级到vim8，那么yum源里面只有一个vim8之前的vim7不能够通过yum源来获取了 这样一来，如果补丁包的版本不是最新的话，是无法通过yum源来直接获得软件的信息的，我们只能通过yum list installed|grep (相关的包名的一部分字符串)来查询。。。说了这么多有点扯远了。开始说正事：difflib模块：介绍：This module provides classes and functions for comparing sequences. It can be used for example, for comparing files, and can produce difference information in various formats, including HTML and context and unified diffs. For comparing directories and files, see also, the filecmp module. 具体用法可以看这里：https://docs.python.org/3/library/difflib.html?highlight=ndiff今天只说字符串的相似度用法. difflib.get_close_matches(word, possibilities, n=3, cutoff=0.6) Return a list of the best “good enough” matches. word is a sequence for which close matches are desired (typically a string), and possibilities is a list of sequences against which to match word (typically a list of strings). Optional argument n (default 3) is the maximum number of close matches to return; n must be greater than 0. Optional argument cutoff (default 0.6) is a float in the range [0, 1]. Possibilities that don’t score at least that similar to word are ignored. The best (no more than n) matches among the possibilities are returned in a list, sorted by similarity score, most similar first. &gt;&gt;&gt; &gt;&gt;&gt; get_close_matches(&#39;appel&#39;, [&#39;ape&#39;, &#39;apple&#39;, &#39;peach&#39;, &#39;puppy&#39;]) [&#39;apple&#39;, &#39;ape&#39;] &gt;&gt;&gt; import keyword &gt;&gt;&gt; get_close_matches(&#39;wheel&#39;, keyword.kwlist) [&#39;while&#39;] &gt;&gt;&gt; get_close_matches(&#39;pineapple&#39;, keyword.kwlist) [] &gt;&gt;&gt; get_close_matches(&#39;accept&#39;, keyword.kwlist) [&#39;except&#39;] get_close_matches()函数，括号里面的参数依次是：目标字符串，要匹配的列表，匹配结果的个数限制，匹配相似度（0-1）。如果未满足要求则返回空列表。","tags":[]},{"title":"关于”科学“！！！","date":"2017-11-20T03:01:47.000Z","path":"2017/11/20/关于”科学“！！！/","text":"之所以把&quot;科学&quot;二字加上引号,从内心觉得科学还是很严谨很高大上的，但是所说内容也是与科学相关的，所以加上了引号，不扯淡了，话说这次好久没写文章了。 一般情况下，我们认为一切事物没有上限（也可能只是我认为。。。），不过也不全是例如：光速是最大的速度，绝对零度是最低的温度。但是本着尽信书不如无书的怀疑一切的态度，我觉得存在比光速还快的速度，比绝对零度还低的温度。这样的怀疑虽然现阶段没有一点理论支撑，但也不是谬论。至少从”认知”（我实在不知道用啥词了）上来讲，比如说这个： 我们人类的“近亲”猿过着平淡无奇的灰色生活。田鼠、家鼠、黄鼠、花鼠、松鼠、草原犬等也不能分辨颜色。长颈鹿能分辨黄色、绿色和橘黄色。鹿对灰色的识别力最强。有趣的是，斑马虽然是色盲，它却能利用色彩来保护自己。斑马和其它动物混在一起吃草，黑白条纹可以引起注意，因此在出现危险时，只要领头马一动，所有斑马会迅速逃走。当斑马奔跑时，黑白两色条纹的晃动使得捕食动物难以快速测定距离，斑马便可安全逃脱。 很多动物是看不到多彩的世界的，那么我们呢，超过快光速，处于绝对零度以下，必然都是超自然的现象，这种现象超出了我们的认知，我们检测不到，所以认为便是“极限”了，当然这种说法也可以分分钟被反驳，因为即使我们无法直观的去检测可以通过其它的不寻常的现象来推断某种东西的存在的，但是这样的发现太难太少，所以即使这种侧面的反馈，也不能用没有发现来直接反驳，就像“神”一样，无法证明，无法否定。当然“神”我倾向无神，但是这种“极限”，我倾向“不存在”。就像紫外线，红外线是不可见光，其实是对于人类“不可见”，以及“超声波”，“低声波”，我们都可以从侧面来确认存在，但是“超光速”，“低绝对零度”，如果存在，远比“声波”，“光”，厉害的多。。。就这样字吧。。。","tags":[]},{"title":"python2之django前端中文乱码中文","date":"2017-09-24T17:53:33.000Z","path":"2017/09/25/python2之django前端中文乱码中文/","text":"把爬取到的数据用于前端展示的时候，结果发现之前的前端存在中文乱码的情况，于是开始了2，3天的debug之旅。。。。现象：前端echarts展示的数据，英文，数字正常显示，中文乱码。排查：先查看了网页源码中乱码的不部分，之后进一步确定目录 templates下的carousel.html中script的data字典的值” 1&#123;&#123; tag_cwe | safe &#125; “乱码，之后得知” 1&#123;&#123; tag_cwe | safe &#125; “在视图views.py中运行django的shell调试输出结合网页源码确定bug的原因： django从数据库获取的数据为中文，而python2中文是以bytes形式存储的。例如 123a = &quot;我&quot;a&#x27;\\xce\\xd2&#x27; 而前端无法解析\\xce\\xd2故而乱码尝试解决：1.将数据转换为utf-8编码之后传至前端​结果：失败。原因：python2对于str类型的数据加有前缀u&#39;，导致前端无法解析2.将数据以base64编码，再有前端解码​结果：成功 后记现在描述起来只有一二百字，但是解决的过程还是相当的扯淡，需要去了解django的架构，以及部分前端，然后！去，踩python2的坑。。。","tags":[]},{"title":"pymysql","date":"2017-09-15T02:46:51.000Z","path":"2017/09/15/pymysql/","text":"import os import json import codecs import pymysql import re jsondir = os.getcwd() + &quot;/all&quot; # print(os.walk(jsondir)) jsonnames = [] for dirs in os.walk(jsondir): jsonnames = dirs[2] conn = pymysql.connect( user = &#39;root&#39;, password = &#39;529966&#39;, host = &#39;localhost&#39;, port = 3306, database = &#39;ceve&#39;, use_unicode=True, charset = &#39;utf8&#39; ) cursor = conn.cursor() for jsonname in jsonnames: f = codecs.open(jsondir+&#39;/&#39;+jsonname,&#39;r&#39;,encoding=&#39;utf-8&#39;) data = json.load(f,encoding=&quot;utf-8&quot;) # print(data) # import pdb # pdb.set_trace() ceve_id = data[&#39;vid&#39;] name = data[&#39;vid&#39;] try: pub_date = data[&#39;published-datetime&#39;] pub_date = re.findall(&quot;(.+?)T&quot;,pub_date)[0] except: pub_date = &quot;null&quot; try: description =data[&#39;description&#39;] description = cursor.connection.escape(description) except: description = &quot;null&quot; # print(type(data[&#39;vuln_cvss&#39;])) try: cvss_score = data[&#39;vuln_cvss&#39;][&#39;cvss_score&#39;] cvss_score = cursor.connection.escape(cvss_score) except: cvss_score = &quot;null&quot; try: cvss_confidentiality_impact = data[&#39;vuln_cvss&#39;][&quot;cvss_confidentiality-impact&quot;] cvss_confidentiality_impact = cursor.connection.escape(cvss_confidentiality_impact) except: cvss_confidentiality_impact = &quot;null&quot; try: cvss_integrity_impact = data[&#39;vuln_cvss&#39;][&quot;cvss_integrity-impact&quot;] cvss_integrity_impact = cursor.connection.escape(cvss_integrity_impact) except: cvss_integrity_impact = &quot;null&quot; try: cvss_availability_impact = data[&#39;vuln_cvss&#39;][&quot;cvss_availability-impact&quot;] cvss_availability_impact = cursor.connection.escape(cvss_availability_impact) except: cvss_availability_impact = &quot;null&quot; try: cvss_access_complexity = data[&#39;vuln_cvss&#39;][&quot;cvss_access-complexity&quot;] cvss_access_complexity = cursor.connection.escape(cvss_access_complexity) except: cvss_access_complexity = &quot;null&quot; try: cvss_access_vector = data[&#39;vuln_cvss&#39;][&quot;cvss_access-vector&quot;] cvss_access_vector = cursor.connection.escape(cvss_access_vector) except: cvss_access_vector = &quot;null&quot; try: cvss_authentication = data[&#39;vuln_cvss&#39;][&#39;cvss_authentication&#39;] cvss_authentication = cursor.connection.escape(cvss_authentication) except: cvss_authentication =&quot;null&quot; # import pdb # pdb.set_trace() # except: # print(jsonname) # ,`published-datetime`,`last-modified-datetime`,`vuln_cvss`,`vuln_cwe`,`vuln_references`,`summary`,`vulnerable-software-list` # cursor.execute(&quot;INSERT INTO vuler_ceve(`ceve_id`,`name`,`pub_date`,`description`,`cvss_score`,`cvss_confidentiality_impact`,`cvss_integrity_impact`,`cvss_availability_impact`,`cvss_access_complexity`,`cvss_access_vector`,`cvss_authentication`) VALUES(ceve_id,name,pub_date,description,cvss_score,cvss_confidentiality_impact,cvss_integrity_impact,cvss_availability_impact,cvss_access_complexity,cvss_access_vector,cvss_authentication)&quot;) try: cursor.execute(&quot;INSERT INTO vuler_ceve(`ceve_id`,`name`,`pub_date`,`description`,`cvss_score`,`cvss_confidentiality_impact`,`cvss_integrity_impact`,`cvss_availability_impact`,`cvss_access_complexity`,`cvss_access_vector`,`cvss_authentication`) VALUES(&#39;%s&#39;,&#39;%s&#39;,&#39;%s&#39;,%s,%s,%s,%s,%s,%s,%s,%s)&quot;%(ceve_id,name,pub_date,description,cvss_score,cvss_confidentiality_impact,cvss_integrity_impact,cvss_availability_impact,cvss_access_complexity,cvss_access_vector,cvss_authentication)) conn.commit() except Exception as e: print(jsonname) print(e) # import pdb # pdb.set_trace() f.close() cursor.close()","tags":[]},{"title":"未来","date":"2017-09-13T02:27:14.000Z","path":"2017/09/13/未来/","text":"最近想了一些东西，关于人生，关于自己，有些问题一直没有答案，但是我丝毫没有停止自己的思考与完善 1、真实的我是什么样的2、未来我要成为什么样子的3、真实的世界是什么样的4、未来的世界将会是什么样的其实未来，对于没有发生的事情谁都说不准，但是我们又总想拿一些人，拿一些事情来做类比，然后推算。所以又必然会产生另外两个问题：5、过去的我是什么样子的6、过去的世界是什么样子的 后面两个虽然已经发生了，客观的事实已经存在了，但是评判必然是也只能是主观所产生的，所以主观上的这个答案又不停的更新，而且永远也不会达到完全的与主观相同。 以前我总说，如果先去知道了不同大学之间的差别，先去感受一下好的大学的魅力,我肯定会更有动力去考更好的大学，肯定也会考上更好的大学，可是现在换个角度来看，不也是一样吗？刚入工作的我，未来找不到方向，找不到自我，在人生的大学上，是不是要去看看，“好的学校”，“差的学校”？去看看最穷的地方，最富的地方，环境最好的地方，环境最差的地方，看看最和善的地方，看看战乱的地方，感受最喧闹的，感受最平静的，感受最豪华的，感受最不堪的，最热的，最冷的。等等，等等，然后，然后我可能会清晰一点，也可能更迷茫了。。。但是一定要试一试！","tags":[]},{"title":"python遇到的问题","date":"2017-09-12T23:51:51.000Z","path":"2017/09/13/python遇到的问题/","text":"此文章用来记录python使用过程中遇到的问题，文章长期更新，作用相当于印象笔记1.sys.argv运行py文件是传入的参数example： python 1.py aa 则sys.argv[0]与sys.argv[1]分别表示 1.py aa","tags":[{"name":"笔记","slug":"笔记","permalink":"https://60ke.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"通过ssh实现mac远程桌面","date":"2017-09-06T00:49:00.000Z","path":"2017/09/06/通过ssh实现mac远程桌面/","text":"teamviewer因为电脑重启的原因，更改了远程登录的密码，但是我没有保存 所以连接不上了。。。 下面是解决办法： 必要条件：可以通过ssh连接！ 首先通过ssh登录mac 通过下面的命令安装teamviewer brew cask install teamviewer 启动teamviewer open /Applications/TeamViewer.app 截图 screencapture /Users/iMac/Desktop/1.png 查看图片获取密码登录即可 teamviewer已经登录被其它窗口挡到怎么办？关闭再重新打开即可！ killall TeamViewer open /Applications/TeamViewer.app","tags":[{"name":"mac","slug":"mac","permalink":"https://60ke.github.io/tags/mac/"}]},{"title":"caogao","date":"2017-09-05T22:46:00.000Z","path":"2017/09/06/caogao/","text":"python 爬虫1.获取网页内容1.1不包含js代码网页对于静态网站，我们可以使用urllib,urllib2,requests，来获取网页的源代码；获取到的源代码，一般与我们在浏览器右键查看网页源代码看到的内容一致 免登录，构造post的爬虫CNVD 1.2包含js代码网页通过前端的js代码生成get，post请求 模拟新浪微博登录爬虫：微博 2.对网页内容的解析常用第三方库BS4 以dict的形式对网页进行解析 lxml xml树状形解析网页 requests 强大的第三方库 框架scrapy 爬虫vmware 3.数据存储3.1存储为指定格式：txt，json，csv等等3.2存储到数据库：mysql，mongodb","tags":[]},{"title":"python对字典进行划分","date":"2017-09-01T02:39:27.000Z","path":"2017/09/01/python对字典进行划分/","text":"code is cheap,show code: 12345678910111213141516171819#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-09-01 15:38:11# @Author : 60ke (worileqing@163.com)# @Link : http://www.worileqing.top# @Version : $Id$import oslist = [&#x27;a1&#x27;,&#x27;a2&#x27;,&#x27;a3&#x27;,&#x27;b1&#x27;,&#x27;b2&#x27;,&#x27;b3&#x27;,&#x27;c1&#x27;]num = len(list)data = &#123;&#125;for i in range(num): try: print(data[&#x27;%s&#x27;%list[i][0]]) except: data[&#x27;%s&#x27;%list[i][0]]=[] if list[i][0] in data: data[&#x27;%s&#x27;%list[i][0]].append(list[i])print(data) result： 12345[&#x27;a1&#x27;][&#x27;a1&#x27;, &#x27;a2&#x27;][&#x27;b1&#x27;][&#x27;b1&#x27;, &#x27;b2&#x27;]&#123;&#x27;a&#x27;: [&#x27;a1&#x27;, &#x27;a2&#x27;, &#x27;a3&#x27;], &#x27;b&#x27;: [&#x27;b1&#x27;, &#x27;b2&#x27;, &#x27;b3&#x27;], &#x27;c&#x27;: [&#x27;c1&#x27;]&#125;","tags":[{"name":"python基础","slug":"python基础","permalink":"https://60ke.github.io/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"python对于词频的统计和排序","date":"2017-08-28T19:00:00.000Z","path":"2017/08/29/python对于词频的统计和排序/","text":"以文件名字为product.txt的文件为例：#!/usr/bin/env python # -*- coding: utf-8 -*- # @Date : 2017-08-29 10:48:30 # @Author : 60ke (worileqing@163.com) # @Link : http://www.worileqing.top # @Version : $Id$ import os with open(&quot;product.txt&quot;,&quot;r&quot;) as f: content = f.read().split(&#39;\\n&#39;) d = dict() for s in content: d[s]=d.get(s,0)+1 print(d) print(len(content)) print(len(d)) print(sorted(d.items(),key=lambda item:item[1],reverse=True)) #reverse=True将结果改为降序 PS:这个词频统计按行分开，对于小说类的成段文字可以参考下面的1.代码来自：http://zwustudy.iteye.com/blog/2236094 #coding=utf-8 &#39;&#39;&#39;&#39;&#39; Created on 2015年8月15日 统计一篇英文文章各个单词出现的词频，并按单次的词频从大到小输出 @author: minmin &#39;&#39;&#39; import re import collections &#39;&#39;&#39;&#39;&#39; 从文件中读取内容，统计词频 &#39;&#39;&#39; def count_word(path): result = &#123;&#125; with open(path) as file_obj: all_the_text = file_obj.read() #大写转小写 all_the_text = all_the_text.lower() #正则表达式替换特殊字符 all_the_text = re.sub(&quot;\\&quot;|,|\\.&quot;, &quot;&quot;, all_the_text) for word in all_the_text.split(): if word not in result: result[word] = 0 result[word] += 1 return result &#39;&#39;&#39;&#39;&#39; 以词频倒序 &#39;&#39;&#39; def sort_by_count(d): #字典排序 d = collections.OrderedDict(sorted(d.items(), key = lambda t: -t[1])) return d if __name__ == &#39;__main__&#39;: file_name = &quot;..\\my father.txt&quot; dword = count_word(file_name) dword = sort_by_count(dword) for key,value in dword.items(): print key + &quot;:%d&quot; % value 2.代码来自http://blog.csdn.net/walkingalien/article/details/54292643 # -*- coding: utf-8 -*- import sys,string,json reload(sys) sys.setdefaultencoding(&#39;utf8&#39;) fr=open(&#39;xyj.txt&#39;,&#39;r&#39;) characters=[] stat=&#123;&#125; for line in fr: line=line.strip() if len(line)==0: continue #print type(line) line=unicode(line) #print type(line) for x in xrange(0,len(line)): if line[x] in [&#39; &#39;,&#39;\\t&#39;,&#39;\\n&#39;,&#39;，&#39;,&#39;.&#39;,&#39;。&#39;,&#39;！&#39;,&#39;：&#39;,&#39;“&#39;,&#39;”&#39;,&#39;？&#39;]: continue if not line[x] in characters: characters.append(line[x]) if not stat.has_key(line[x]): stat[line[x]]=0 stat[line[x]]+=1 fw=open(&#39;result.json&#39;,&#39;w&#39;) fw.write(json.dumps(stat)) fw.close() stat=sorted(stat.iteritems(),key=lambda d:d[1],reverse=True ) print type(characters[0]) for x in xrange(0,20): print characters[x] print &#39;********************************************&#39; print type(stat[0][0]) for x in xrange(0,20): print stat[x][0],stat[x][1] fw=open(&#39;result.csv&#39;,&#39;w&#39;) for item in stat: fw.write(item[0]+&#39;:&#39;+str(item[1])+&#39;\\n&#39;) fw.close() fr.close() 输出： &lt;type &#39;unicode&#39;&gt; 吴 承 恩 著 第 一 回 灵 根 育 孕 源 流 出 心 性 修 持 大 ******************************************** &lt;type &#39;unicode&#39;&gt; 道 10023 不 7984 了 7144 一 7079 那 6934 我 6575 是 5907 行 5474 来 5431 他 5297 个 5206 你 5086 的 4971 者 4887 有 3909 大 3603 得 3514 这 3481 去 3377 上 3260 [Finished in 19.7s]","tags":[]},{"title":"python字母与数字","date":"2017-08-24T22:33:46.000Z","path":"2017/08/25/python字母与数字/","text":"code： f = 5 x=97 for i in range(f): print(chr(x),&quot;:&quot;,i+1) x+=1 outputa : 1 b : 2 c : 3 d : 4 e : 5","tags":[]},{"title":"scrapy保存数据为多个json","date":"2017-08-22T22:26:33.000Z","path":"2017/08/23/scrapy保存数据为多个json/","text":"定义pipline：# -*- coding: utf-8 -*- # Define your item pipelines here # # Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html # class VmwarePipeline(object): # def process_item(self, item, spider): # return item import json import codecs class VmwarePipeline(object): def process_item(self, item, spider): self.file = codecs.open(&#39;%s.json&#39;%item[&#39;vid&#39;], &#39;w&#39;, encoding=&#39;utf-8&#39;) line = json.dumps(dict(item), ensure_ascii=False) + &quot;\\n&quot; self.file.write(line) return item def spider_closed(self, spider): self.file.close() PS：scrapy中spiders的解析不能执行的问题目前为止遇到的情况有两种 解析函数本身存在问题，解析错误导致不能继续传递 解析的网址不在定义的allowed_domains中（这个比较坑，因为scrapy对于是否在allowed_domains的判断不够准确，没有必要的话最好不写这个allowed_domains）","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://60ke.github.io/tags/scrapy/"}]},{"title":"pycharm安装及主题更换","date":"2017-08-21T22:07:23.000Z","path":"2017/08/22/pycharm安装及主题更换/","text":"进入官网下载pycharm专业版：https://download.jetbrains.8686c.com/python/pycharm-community-2017.2.1.exe 到一下网站获取注册码：http://idea.lanyus.com/ 主题：https://github.com/d1ffuz0r/pycharm-themes windows下的主题安装：将下载的icls文件拷贝到C:\\Users***.PyCharm30\\config\\colors在pycharm的file-&gt;Setting-&gt;Editor-&gt;Colors &amp; Fonts里就可以看到刚刚下载的颜色字体主题包","tags":[{"name":"pycharm","slug":"pycharm","permalink":"https://60ke.github.io/tags/pycharm/"}]},{"title":"scrapy之获取ubuntu安全公告，并将cve存储为json","date":"2017-08-21T19:33:00.000Z","path":"2017/08/22/scrapy之获取ubuntu安全公告，并将cve存储为json/","text":"创建ubuntu项目scrapy startproject ubuntu 创建spider模板cd ubuntu scrapy genspider Ubuntu https://usn.ubuntu.com cat ubuntu/ubuntu/spiders/Ubuntu.py # -*- coding: utf-8 -*- import scrapy class UbuntuSpider(scrapy.Spider): name = &#39;Ubuntu&#39; allowed_domains = [&#39;https://usn.ubuntu.com&#39;] start_urls = [&#39;http://https://usn.ubuntu.com/&#39;] def parse(self, response): pass ~ 编写spider# -*- coding: utf-8 -*- import scrapy from bs4 import BeautifulSoup import re import requests from ubuntu.items import UbuntuItem class UbuntuSpider(scrapy.Spider): name = &#39;Ubuntu&#39; allowed_domains = [&#39;usn.ubuntu.com&#39;] def start_requests(self): url = &quot;https://usn.ubuntu.com/usn/&quot; content = requests.get(url).text soup = BeautifulSoup(content,&quot;html.parser&quot;) page = soup.find(attrs=&#123;&quot;class&quot;:&quot;right&quot;&#125;).text.strip() max_page = re.findall(&quot;Showing page 1 of (.+?) &quot;,page)[0] start_urls = [] for page in range(int(max_page)): page +=1 url = &#39;https://usn.ubuntu.com/usn/?page=%s&#39;%page yield scrapy.Request(url,callback=self.parse0) def parse0(self, response): # 获取公告中usn的cve_url cves = response.xpath(&quot;//@href&quot;).extract() for cve in cves: if cve.startswith(&quot;http://people.ubuntu.com/~ubuntu-security/cve/&quot;): item = UbuntuItem() item[&#39;cve&#39;] = cve yield item 需要注意的地方： 通常需要重写start_requests()函数 导入模块语句from ubuntu.items import UbuntuItem 定义itemitem = UbuntuItem()注意后面的括号 存储为json1.定义item # -*- coding: utf-8 -*- # Define here the models for your scraped items # # See documentation in: # http://doc.scrapy.org/en/latest/topics/items.html import scrapy class UbuntuItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() cve = scrapy.Field() 2.定义piplines # -*- coding: utf-8 -*- # Define your item pipelines here # # Don&#39;t forget to add your pipeline to the ITEM_PIPELINES setting # See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html import json import codecs # class UbuntuPipeline(object): # def process_item(self, item, spider): # return item class UbuntuPipeline(object): def __init__(self): self.file = codecs.open(&#39;cve.json&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) def process_item(self, item, spider): line = json.dumps(dict(item), ensure_ascii=False) + &quot;\\n&quot; self.file.write(line) return item def spider_closed(self, spider): self.file.close() 3.spider中保存item的语句（见上面） 4.settings设置 ITEM_PIPELINES = &#123; &#39;ubuntu.pipelines.UbuntuPipeline&#39;: 300, &#125; ps:写包含代码的文章的时候，不要用ctrl+u,ctrl+o来创建列表，会造成ctrl+k的代码显示不正常","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://60ke.github.io/tags/scrapy/"}]},{"title":"scrapy-xpath用法","date":"2017-08-21T18:04:10.000Z","path":"2017/08/22/scrapy-xpath用法/","text":"转载自http://www.cnblogs.com/huhuuu/p/3701017.html Scrapy是基于python的开源爬虫框架，使用起来也比较方便。具体的官网档：http://doc.scrapy.org/en/latest/ 之前以为了解python就可以直接爬网站了，原来还要了解HTML，XML的基本协议，在了解基础以后，在了解下xpath的基础上，再使用正则表达式(python下的re包提供支持)提取一定格式的信息（比如说url），就比较容易处理网页了。 xpath是Scrapy下快速提取特定信息（如title,head,href等）的一个接口。 几个简单的例子： /html/head/title: 选择HTML文档元素下面的 标签。 /html/head/title/text(): 选择前面提到的 元素下面的文本内容 //td: 选择所有 元素 //div[@class=”mine”]: 选择所有包含 class=”mine” 属性的div 标签元素 基本的路径意义： 表达式 描述nodename 选取此节点的所有子节点。/ 从根节点选取。// 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。. 选取当前节点。.. 选取当前节点的父节点。@ 选取属性。 具体的使用实例： 比如对http://www.dmoz.org/Computers/Programming/Languages/Python/Books/ 网站提取特定的信息 1）、先在第一层tutorial文件夹下，在cmd中输入： scrapy shell http://www.dmoz.org/Computers/Programming/Languages/Python/Books/ 2）、现在比如我们需要抓取该网页的tittle，由于前面的shell命令已经实例化了一个selector的对象sel， 就输入 sel.xpath(‘//title’) 获取了网页的标题。 3）、比如我们想要知道该网页下的www.****.com形式的链接，可以使用xpath 结合正则表达式re提取信息，输入 sel.xpath(‘//@href’).re(“www.[0-9a-zA-Z]+.com”)","tags":[{"name":"scrapy","slug":"scrapy","permalink":"https://60ke.github.io/tags/scrapy/"},{"name":"xpath","slug":"xpath","permalink":"https://60ke.github.io/tags/xpath/"}]},{"title":"ubuntu常用的一些设置","date":"2017-08-17T18:12:00.000Z","path":"2017/08/18/ubuntu常用的一些设置/","text":"运行程序时出现：unable to resolve host ke的解决办法： sudo vi /etc/hosts 在hosts里面添加 127.0.0.1 localhost ke(hostname) hostname可用 hostname 用户名 的方法更改hostname，vi /etc/hostname可用永久更改hostname ubuntu设置默认python： sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 切换： sudo update-alternatives --config python","tags":[]},{"title":"python爬虫之——网页解析","date":"2017-08-17T02:18:00.000Z","path":"2017/08/17/python爬虫之——网页解析/","text":"常用的正则首先导入第三方包 import re 常用的正则函数： re.findall()re.findall()这个函数之前用的已经比较多了，除了以前提到的re.findall(“”,target)在“”中放入（.+?）来匹配要查找到内容，还可以结合python中 r+“”的特性，来进行正则查找，同时还可以使用多个（）来查找多个，之后再加上“”.jion(list)来实现list转字符串，然后又可以利用str.replace(“”,””)来实现字符串的替换，talk is cheap，show you code import requests import re url = &quot;http:// \\&quot;www.baidu.com http://www.baidu.com http://www.baidu.com http://www.baidu.com http://www.baidu.com&quot; target_r = re.findall(r&quot;http:(.+?) \\&quot;&quot;,url) target = &quot;&quot;.join(re.findall(&quot;http:(.+?) \\&quot;&quot;,url)).replace(&quot;//&quot;,&quot;haha&quot;) print(target_r) print(target) 输出的结果：[‘//‘]haha re.compile()import re cveid = &quot;CVE-2015-3456&quot; pat = re.compile(&#39;CVE-(\\d+)-\\d+&#39;) m = pat.search(cveid) year = m.group(1) print(pat) print(m) print(year) 输出结果： re.compile(&#39;CVE-(\\\\d+)-\\\\d+&#39;) &lt;_sre.SRE_Match object; span=(0, 13), match=&#39;CVE-2015-3456&#39;&gt; 2015 beautifulsoupbeautifulsoup 以我最近写的代码为例 # -*- coding: utf-8 -*- import os import re import requests from bs4 import BeautifulSoup import json url = &quot;http://www.huawei.com/cn/psirt/security-advisories/huawei-sa-20160706-01-openssl-cn&quot; page = requests.get(url=str(url)).text html = requests.get(url=str(url)).content soup = BeautifulSoup(page,&quot;html.parser&quot;) content = soup.find(attrs=&#123;&#39;class&#39;:&#39;col-sm-9 psiet-detail&#39;&#125;) published_datetime = content.find(attrs=&#123;&#39;id&#39;:&#39;indexmain_0_liInieialReleaseDate&#39;&#125;).text a = re.findall(r&#39;(\\d+-\\d+-\\d+)&#39;,published_datetime)[0] last_modified_datetime = content.find(attrs=&#123;&#39;id&#39;:&#39;indexmain_0_liLastReleaseDate&#39;&#125;).text b = re.findall(r&#39;(\\d+-\\d+-\\d+)&#39;,last_modified_datetime)[0] name = content.find(attrs=&#123;&#39;class&#39;:&#39;bor-btom&#39;&#125;).text.strip() cvss_score = content.find(attrs=&#123;&#39;class&#39;: &#39;psirt-list-out&#39;&#125;).find_all(attrs=&#123;&quot;class&quot;: &quot;psirt-set-out&quot;&#125;)[3].find(attrs=&#123;&quot;class&quot;:&quot;moreinfo&quot;&#125;).text tab = soup.findAll(&#39;table&#39;)[0] vulnerable_software_list = [] for tr in tab.findAll(&#39;tr&#39;): #print((tr.text)) vulnerable_software_list.append(tr.text) print(vulnerable_software_list) 输出结果 [&#39;\\n\\n产品名称\\n\\n\\n版本号\\n\\n\\n修复版本号\\n\\n&#39;, &#39;\\n\\n9032\\n\\n\\nV100R001C00\\n\\n\\nV100R001C00SPC101\\n\\n&#39;, &#39;\\n\\n\\xa0Agile Controller-Campus\\n\\n\\nV100R001C00\\n\\n\\nUpgrade to V100R002C10SPC400\\n\\n&#39;, &#39;\\n\\nV100R002C00\\n\\n&#39;, &#39;\\n\\nV100R002C10\\n\\n\\nV100R002C10SPC400\\n\\n&#39;, &#39;\\n\\nAnyOffice\\n\\n\\nV200R002C20\\n\\n\\nUpgrade to V200R006C00\\n\\n&#39;, &#39;\\n\\nV200R003C00\\n\\n&#39;, &#39;\\n\\nV200R005C00\\n\\n&#39;, &#39;\\n\\n\\xa0AR510\\n\\n\\nV200R005C30\\n\\n\\nUpgrade to V200R008C20\\n\\n&#39;, &#39;\\n\\n\\xa0BH620\\n\\n\\nV100R001C00\\n\\n\\nV100R001C00SPC106\\xa0 \\n\\n&#39;, &#39;\\n\\n\\xa0BH620 V2\\n\\n\\nV100R002C00\\n\\n\\nV100R002C00SPC301B010\\n\\n&#39;, &#39;\\n\\n\\xa0CH221\\n\\n\\nV100R001C00\\n\\n\\nV100R001C00SPC266\\n\\n&#39;, &#39;\\n\\nCH225 V3\\n\\n\\nV100R001C00\\n\\n\\nV100R001C00SPC102\\n\\n&#39;, &#39;\\n\\nE5372s\\n\\n\\nE5372s-32TCPU-V200R001B290D23SP00C00\\n\\n\\nE5372s-32TCPU-V200R001B290D25SP00C00 \\n\\n&#39;, &#39;\\n\\nE5377Bs\\n\\n\\nE5377Bs-605TCPU-V200R001B305D09SP00C00\\n\\n\\nE5377Bs-605TCPU-V200R001B313D13SP00C00\\n\\n&#39;, &#39;\\n\\nE5786s\\n\\n\\nE5786s-32aTCPU-V200R001B313D15SP00C00\\n\\n\\nE5786s-32aTCPU-V200R001B313D17SP00C00\\n\\n&#39;, &#39;\\n\\nE5878s\\n\\n\\nE5878s-32TCPU-V200R001B305D11SP00C00\\n\\n\\nE5878s-32TCPU-V200R001B313D13SP00C00 \\n\\n&#39;, &#39;\\n\\nE6000 Chassis\\n\\n\\nV100R001C00\\n\\n\\nV100R001C00SPC501B010\\n\\n&#39;, &#39;\\n\\nE9000 Chassis\\n\\n\\nV100R001C00\\n\\n\\nV100R001C00SPC296\\n\\n&#39;, &#39;\\n\\nEEM\\n\\n\\nV200R007C00\\n\\n\\nUpgrade to V200R008C10\\n\\n&#39;, &#39;\\n\\nV200R007C10\\n\\n&#39;, &#39;\\n\\nV200R007C20\\n\\n&#39;, &#39;\\n\\nV200R008C00\\n\\n&#39;, &#39;\\n\\neLog\\n\\n\\nV200R005C00\\n\\n\\nV200R005C00SPC101\\n\\n&#39;, &#39;\\n\\neSDK Platform \\n\\n\\nV100R005C30\\n\\n\\nUpgrade to V100R005C60\\n\\n&#39;, &#39;\\n\\neSight Network\\n\\n\\nV300R003C20\\n\\n\\nV300R003C20SPC106\\n\\n&#39;, &#39;\\n\\nV300R005C00\\n\\n\\nV300R005C00SPC302\\n\\n&#39;, &#39;\\n\\neSpace IVS\\n\\n\\neSpace IVS V100R001C02SPC100\\n\\n\\nUpgrade to eSpace VCN3000 V100R001C01SPC132\\n\\n&#39;, &#39;\\n\\nEudemon8000E-X8\\n\\n\\nV300R001C01\\n\\n\\nV300R001C01SPCA00\\n\\n&#39;, &#39;\\n\\nV500R001C00\\n\\n\\nUpgrade to V500R002C00SPC100\\n\\n&#39;, &#39;\\n\\nFireHunter6000\\n\\n\\nV100R001C20\\n\\n\\nV100R001C20SPC101\\n\\n&#39;, &#39;\\n\\nFusionAccess\\n\\n\\nV100R003C00\\n\\n\\nUpgrade to V100R006C00\\n\\n&#39;, &#39;\\n\\nV100R005C10\\n\\n&#39;, &#39;\\n\\nV100R005C20\\n\\n&#39;, &#39;\\n\\nV100R005C30\\n\\n&#39;, &#39;\\n\\nFusionInsight HD\\n\\n\\nV100R002C50\\n\\n\\nUpgrade to V100R002C60SPC200\\n\\n&#39;, &#39;\\n\\nFusionInsight\\n\\n\\nFusionInsight V100R002C30\\n\\n\\nUpgrade to FusionInsight HD V100R002C60SPC200\\n\\n&#39;, &#39;\\n\\nFusionManager\\n\\n\\nFusionManager V100R003C10\\n\\n\\nUpgrade to FusionSphere OpenStack V100R006C00RC3B036\\n\\n&#39;, &#39;\\n\\nFusionManager V100R005C00\\n\\n&#39;, &#39;\\n\\nFusionManager V100R005C10SPC700\\n\\n&#39;, &#39;\\n\\nFusionManager V100R006C00\\n\\n&#39;, &#39;\\n\\nFusionStorage DSware\\n\\n\\nFusionStorage DSware V100R003C02\\n\\n\\nUpgrade to FusionStorage V100R003C30U1SPC001\\n\\n&#39;, &#39;\\n\\nFusionStorage DSware V100R003C30\\n\\n\\nUpgrade to FusionStorage V100R003C30U1SPC001\\n\\n&#39;, &#39;\\n\\nFusionStorage\\n\\n\\nV100R003C00\\n\\n\\nUpgrade to V100R003C30U1SPC001\\n\\n&#39;, &#39;\\n\\nG710-C00\\n\\n\\nV100R001C92B118\\n\\n\\nV100R001C92B135\\n\\n&#39;, &#39;\\n\\nHG253s V2-20\\n\\n\\nV100R001C205B027\\n\\n\\nV100R001C205B052\\n\\n&#39;, &#39;\\n\\nHG255s-10\\n\\n\\nV100R001C163B013\\n\\n\\nV100R001C163B026\\n\\n&#39;, &#39;\\n\\xa0\\n HiSTBAndroid\\n\\n\\nV600R001C00SPC060\\n\\n\\xa0\\n V600R001C00CP0013\\n\\n&#39;, &#39;\\n\\niBMC\\n\\n\\nV100R002C10\\n\\n\\nUpgrade to \\xa0V200R002C10\\n\\n&#39;, &#39;\\n\\nV100R002C30\\n\\n&#39;, &#39;\\n\\nIVS\\n\\n\\nIVS V100R002C10\\n\\n\\nUpgrade to eSpace VCN3000 V100R002C10SPC108\\n\\n&#39;, &#39;\\n\\nLogCenter\\n\\n\\nV100R001C10\\n\\n\\nUpgrade to V100R001C20SPC102\\n\\n&#39;, &#39;\\n\\nV100R001C20\\n\\n\\nV100R001C20SPC102\\n\\n&#39;, &#39;\\n\\nMT992-10\\n\\n\\nMV100R001C01B002\\n\\n\\nV100R001C01B019\\n\\n&#39;, &#39;\\n\\nOceanStor 18500\\n\\n\\nV100R001C10\\n\\n\\nUpgrade to V100R001C30SPC201\\n\\n&#39;, &#39;\\n\\nOceanStor 18800 V3\\n\\n\\nV300R003C00\\n\\n\\nUpgrade to V300R003C10SPC100\\n\\n&#39;, &#39;\\n\\nOceanStor 2860 V3\\n\\n\\nOceanStor 2860 V3 V300R001C00T\\n\\n\\nUpgrade to OceanStor 2800 V300R003C20\\n\\n&#39;, &#39;\\n\\nOceanStor 5600 V3\\n\\n\\nV300R001C00\\n\\n\\nUpgrade to \\xa0V300R003C10SPC100\\n\\n&#39;, &#39;\\n\\nOceanStor 5600 V3\\n\\n\\nV300R003C00\\n\\n\\nUpgrade to V300R003C10SPC100\\n\\n&#39;, &#39;\\n\\nOceanStor 5600 V3\\n\\n\\nV300R003C10\\n\\n\\nV300R003C10SPC100\\n\\n&#39;, &#39;\\n\\nOceanStor 5800 V3\\n\\n\\nV300R002C00\\n\\n\\nUpgrade to V300R003C10SPC100\\n\\n&#39;, &#39;\\n\\nOceanStor 9000\\n\\n\\nO\\xa0 V100R001C01\\n\\n\\nUpgrade to V300R005C00SPC170\\n\\n&#39;, &#39;\\n\\nV100R001C30\\n\\n\\nOV300R005C00SPC170\\n\\n&#39;, &#39;\\n\\nOceanStor 9000E\\n\\n\\nOceanStor 9000E V100R001C01\\n\\n\\nUpgrade to OceanStor 9000 V300R005C00SPC170\\n\\n&#39;, &#39;\\n\\nOceanStor 9000E V100R002C00\\n\\n&#39;, &#39;\\n\\nOceanStor 9000E V100R002C19\\n\\n&#39;, &#39;\\n\\nOceanStor Backup \\xa0Software\\n\\n\\nV100R002C00\\n\\n\\nV100R002C00LHWS01SPC100\\n\\n&#39;, &#39;\\n\\nOceanStor BCManager\\n\\n\\nV100R005C00\\n\\n\\nUpgrade to V200R001C00\\n\\n&#39;, &#39;\\n\\nOceanStor CSE\\n\\n\\nOceanStor CSE V100R002C00LSFM01B010\\n\\n\\nUpgrade to OceanStor Onebox V100R002C00LSFM01SPC108\\n\\n&#39;, &#39;\\n\\nOceanStor HVS85T\\n\\n\\nOceanStor HVS85T V100R001C30\\n\\n\\nOceanStor 18500 V100R001C30SPC201\\n\\n&#39;, &#39;\\n\\nOceanStor HVS85T\\n\\n\\nOceanStor HVS85T V100R001C30\\n\\n\\nOceanStor 18500 V100R001C30SPC201\\n\\n&#39;, &#39;\\n\\nOceanStor N8500\\n\\n\\nV200R001C09\\n\\n\\nV200R001C09SPC506\\n\\n&#39;, &#39;\\n\\nV200R001C91\\n\\n\\nV200R001C91SPC902\\n\\n&#39;, &#39;\\n\\nPolicy Center\\n\\n\\nPolicy Center V100R003C00\\n\\n\\nUpgrade to Agile Controller-Campus V100R002C10SPC400\\xa0 \\n\\n&#39;, &#39;\\n\\nPolicy Center V100R003C10\\n\\n&#39;, &#39;\\n\\nPublic Cloud Solution\\n\\n\\nPublic Cloud Solution OpsTools 1.0.3\\n\\n\\nPublic Cloud Solution 1.0.9\\n\\n&#39;, &#39;\\n\\nPublic Cloud Solution V100R001C00\\n\\n&#39;, &#39;\\n\\nRH1288 V3\\n\\n\\nV100R003C00SPC100\\n\\n\\nV100R003C00SPC613\\n\\n&#39;, &#39;\\n\\nRH2285H V2\\n\\n\\nV100R002C00\\n\\n\\nV100R002C00SPC505\\n\\n&#39;, &#39;\\n\\nRH5885 V2\\n\\n\\nV100R001C00\\n\\n\\nUpgrade to V100R001C02SPC302\\n\\n&#39;, &#39;\\n\\nRH5885 V3\\n\\n\\nV100R003C00\\n\\n\\nUpgrade to V100R003C10SPC102\\n\\n&#39;, &#39;\\n\\nV100R003C01\\n\\n\\nUpgrade to V100R003C10SPC102\\n\\n&#39;, &#39;\\n\\nRH8100 V3\\n\\n\\nV100R003C00\\n\\n\\nV100R003C00SPC207\\n\\n&#39;, &#39;\\n\\nSoftVCN\\n\\n\\nV100R002C20\\n\\n\\nV100R002C20SPC100\\n\\n&#39;, &#39;\\n\\npeedport Hybrid\\n\\n\\nV100R001C01B021\\n\\n\\nUpgrade to V100R001C03B012\\n\\n&#39;, &#39;\\n\\nUSG9560\\n\\n\\nUSG9560 V300R001C20\\n\\n\\nUpgrade to USG9500 V500R001C30\\n\\n&#39;, &#39;\\n\\nUSG9560 V300R002C00\\n\\n\\nUpgrade to USG9500 V500R001C30\\xa0 \\n\\n&#39;, &#39;\\n\\nVCM\\n\\n\\nV100R001C10\\n\\n\\nV100R001C10SPC006\\n\\n&#39;, &#39;\\n\\nVCM5010\\n\\n\\nVCM5010 V100R002C20\\n\\n\\nUpgrade to VCM5020 V100R002C20\\n\\n&#39;, &#39;\\n\\nXH320\\n\\n\\nXH320 V100R001C00\\n\\n\\nUpgrade to Tecal X6000 V100R001C02\\n\\n&#39;, &#39;\\n\\nXH620\\n\\n\\nXH620 V100R001C00\\n\\n\\nUpgrade to XH620 V3 V100R003C00\\n\\n&#39;] 补充以前用BeautifulSoup一直用的”html.parser”的解析器，今天补充一下其他的http://bbs.csdn.net/topics/392161042?list=lz","tags":[]},{"title":"爬虫入门到进阶-1--保存一张图片","date":"2017-06-26T08:18:39.000Z","path":"2017/06/26/爬虫入门到进阶-1--保存一张图片/","text":"# -*- coding: utf-8 -*- //可以避免一些编码问题 import urllib.request //python3自带的模块，用来做网页的解析 url = &quot;http://gaopin-preview.bj.bcebos.com/133208713368.jpg&quot; //定义要爬取的网址 response = urllib.request.urlopen(url) //用urllib.request.urlopen打开网页并将其传递给response with open(&#39;1.jpg&#39;,&#39;wb&#39;) as f: //以二进制方式打开一个名为1.jpg的文件，并将其作为f变量（对象） f.write(response.read()) //读取response并将其写入到f中","tags":[]},{"title":"ubuntu中安装R和Rstudio","date":"2017-06-12T06:24:45.000Z","path":"2017/06/12/ubuntu中安装R和Rstudio/","text":"转载自 作者：会心一击出处：http://www.cnblogs.com/lijingchn/ 安装R 1.1 首先添加镜像源 sudo gedit /etc/apt/sources.list加入新镜像源：deb http://cran.rstudio.com/bin/linux/ubuntu trusty/1.2 运行命令下载公钥 sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys 51716619E084DAB9然后更新一下sudo apt-get update1.3 安装R sudo apt-get install r-base然后验证是否安装成功：在终端输入R，出现R的信息则安装成功。 安装Rstudio 2.1 安装 首先，去下载对应自己系统的安装文件: http://www.rstudio.com/products/rstudio/download/，然后执行一下步骤。 sudo apt-get install gdebi-coresudo apt-get install libapparmor1 # Required only for Ubuntu, not Debian sudo gdebi 下载的Rstudio的deb安装包2.2 在Rstudio里安装ggplot2 安装ggplot2包之前需要先安装其它的依赖包：’ plyr ‘ , ‘ digest ‘ , ‘ gtable ‘ , ‘ reshape2 ‘ , ‘ scales ‘ , ‘ proto ‘ , 在Rstudio的命令窗口分别执行以下命令。 复制代码install.packages(‘plyr’)install.packages(‘digest’)install.packages(‘gtable’)install.packages(‘reshape2’)install.packages(‘scales’)install.packages(‘proto’)复制代码然后，安装 ‘ ggplot2 ‘ 包 , 安装成功后就可以使用了。 install.packages(‘ggplot2’)","tags":[]},{"title":"解决Ubuntu下Sublime Text 2无法输入中文","date":"2017-06-10T20:57:48.000Z","path":"2017/06/11/解决Ubuntu下Sublime Text 2无法输入中文/","text":"ubuntu16.04下sublime text 2无法输入中文的问题 保存下面的代码到文件sublime_imfix.c(位于~目录，即主文件夹目录) #include &lt;gtk/gtkimcontext.h&gt; void gtk_im_context_set_client_window (GtkIMContext *context, GdkWindow *window) { GtkIMContextClass *klass; g_return_if_fail (GTK_IS_IM_CONTEXT (context)); klass = GTK_IM_CONTEXT_GET_CLASS (context); if (klass-&gt;set_client_window) klass-&gt;set_client_window (context, window); g_object_set_data(G_OBJECT(context),”window”,window); if(!GDK_IS_WINDOW (window)) return; int width = gdk_window_get_width(window); int height = gdk_window_get_height(window); if(width != 0 &amp;&amp; height !=0) gtk_im_context_focus_in(context); } 将上一步的代码编译成共享库libsublime-imfix.so然后将libsublime-imfix.so拷贝到sublime_text所在文件夹,修改文件/usr/bin/subl的内容 cd ~ gcc -shared -o libsublime-imfix.so sublime_imfix.c pkg-config --libs --cflags gtk+-2.0 -fPIC sudo mv libsublime-imfix.so /opt/sublime_text_2/将 #!/bin/sh /opt/sublime_text_2/sublime_text “$@” 修改为 #!/bin/sh LD_PRELOAD=/opt/sublime_text_2/libsublime-imfix.so exec /opt/sublime_text_2/sublime_text &quot;$@&quot;","tags":[]},{"title":"Anaconda使用说明","date":"2017-04-26T02:07:04.000Z","path":"2017/04/26/Anaconda使用说明/","text":"Anaconda常用的命令： -conda list 查看安装了哪些包。 conda env list 或 conda info -e 查看当前存在哪些虚拟环境 conda update conda 检查更新当前conda conda -V 查看conda版本 创建使用Python虚拟环境：conda create -n your_env_name python=X.X（2.7、3.6等） 打开命令行输入python --version可以检查当前python的版本。 使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。 Linux: source activate your_env_name(虚拟环境名称) Windows: activate your_env_name(虚拟环境名称) 对虚拟环境中安装额外的包：使用命令`conda install -n your_env_name [package]`即可安装package到your_env_name中 关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)： 使用如下命令即可。 Linux: source deactivate Windows: deactivate 删除虚拟环境： 使用命令conda remove -n your_env_name(虚拟环境名称) --all， 即可删除。 删除环境中的某个包： 使用命令conda remove --name $your_env_name $package_name 即可。","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"}]},{"title":"win10开启UbuntuBash并实现xshell登录","date":"2017-04-26T01:18:00.000Z","path":"2017/04/26/win10开启UbuntuBash并实现xshell登录/","text":"看到win10内置ubuntubash没忍住，又把系统换成了win10 一，开启Bash 把系统设置改为开发人员模式 经控制面板进入程序开启Ubuntu子系统 打开cmd输入bash开始下载Ps:不翻墙，正常情况下是无法下载的下面是解决下载的办法1.更改系统设置的区域为香港特别行政区2.更改本地dns为微软的dns：4.2.2.1; 4.2.2.2等待下载完成就好： 二，开启ssh 设置root密码：打开bash默认root登陆，用一下命令设置root密码： passwd root 开启ssh service ssh start 设置sshd vi etc/ssh/sshd_config 将PasswordAuthentication改为yes，PermitRootLogin改为yesPS：如果（密匙登陆的情况）出现could not load host key的错误可以用dpkg-reconfigure openssh-server 生成","tags":[]},{"title":"转载-Python 爬虫：把廖雪峰的教程转换成 PDF 电子书","date":"2017-04-22T01:39:41.000Z","path":"2017/04/22/转载-Python 爬虫：把廖雪峰的教程转换成 PDF 电子书/","text":"来源：https://github.com/lzjun567/crawler_html2pdf/blob/master/pdf/crawler.py # coding=utf-8 from __future__ import unicode_literals import logging import os import re import time try: from urllib.parse import urlparse # py3 except: from urlparse import urlparse # py2 import pdfkit import requests from bs4 import BeautifulSoup html_template = &quot;&quot;&quot; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &#123;content&#125; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot; class Crawler(object): &quot;&quot;&quot; 爬虫基类，所有爬虫都应该继承此类 &quot;&quot;&quot; name = None def __init__(self, name, start_url): &quot;&quot;&quot; 初始化 :param name: 保存问的PDF文件名,不需要后缀名 :param start_url: 爬虫入口URL &quot;&quot;&quot; self.name = name self.start_url = start_url self.domain = &#39;&#123;uri.scheme&#125;://&#123;uri.netloc&#125;&#39;.format(uri=urlparse(self.start_url)) def crawl(self, url): &quot;&quot;&quot; pass :return: &quot;&quot;&quot; print(url) response = requests.get(url) return response def parse_menu(self, response): &quot;&quot;&quot; 解析目录结构,获取所有URL目录列表:由子类实现 :param response 爬虫返回的response对象 :return: url 可迭代对象(iterable) 列表,生成器,元组都可以 &quot;&quot;&quot; raise NotImplementedError def parse_body(self, response): &quot;&quot;&quot; 解析正文,由子类实现 :param response: 爬虫返回的response对象 :return: 返回经过处理的html文本 &quot;&quot;&quot; raise NotImplementedError def run(self): start = time.time() options = &#123; &#39;page-size&#39;: &#39;Letter&#39;, &#39;margin-top&#39;: &#39;0.75in&#39;, &#39;margin-right&#39;: &#39;0.75in&#39;, &#39;margin-bottom&#39;: &#39;0.75in&#39;, &#39;margin-left&#39;: &#39;0.75in&#39;, &#39;encoding&#39;: &quot;UTF-8&quot;, &#39;custom-header&#39;: [ (&#39;Accept-Encoding&#39;, &#39;gzip&#39;) ], &#39;cookie&#39;: [ (&#39;cookie-name1&#39;, &#39;cookie-value1&#39;), (&#39;cookie-name2&#39;, &#39;cookie-value2&#39;), ], &#39;outline-depth&#39;: 10, &#125; htmls = [] for index, url in enumerate(self.parse_menu(self.crawl(self.start_url))): html = self.parse_body(self.crawl(url)) f_name = &quot;.&quot;.join([str(index), &quot;html&quot;]) with open(f_name, &#39;wb&#39;) as f: f.write(html) htmls.append(f_name) pdfkit.from_file(htmls, self.name + &quot;.pdf&quot;, options=options) for html in htmls: os.remove(html) total_time = time.time() - start print(u&quot;总共耗时：%f 秒&quot; % total_time) class LiaoxuefengPythonCrawler(Crawler): &quot;&quot;&quot; 廖雪峰Python3教程 &quot;&quot;&quot; def parse_menu(self, response): &quot;&quot;&quot; 解析目录结构,获取所有URL目录列表 :param response 爬虫返回的response对象 :return: url生成器 &quot;&quot;&quot; soup = BeautifulSoup(response.content, &quot;html.parser&quot;) menu_tag = soup.find_all(class_=&quot;uk-nav uk-nav-side&quot;)[1] for li in menu_tag.find_all(&quot;li&quot;): url = li.a.get(&quot;href&quot;) if not url.startswith(&quot;http&quot;): url = &quot;&quot;.join([self.domain, url]) # 补全为全路径 yield url def parse_body(self, response): &quot;&quot;&quot; 解析正文 :param response: 爬虫返回的response对象 :return: 返回处理后的html文本 &quot;&quot;&quot; try: soup = BeautifulSoup(response.content, &#39;html.parser&#39;) body = soup.find_all(class_=&quot;x-wiki-content&quot;)[0] # 加入标题, 居中显示 title = soup.find(&#39;h4&#39;).get_text() center_tag = soup.new_tag(&quot;center&quot;) title_tag = soup.new_tag(&#39;h1&#39;) title_tag.string = title center_tag.insert(1, title_tag) body.insert(1, center_tag) html = str(body) # body中的img标签的src相对路径的改成绝对路径 pattern = &quot;(&lt;img .*?src=\\&quot;)(.*?)(\\&quot;)&quot; def func(m): if not m.group(3).startswith(&quot;http&quot;): rtn = &quot;&quot;.join([m.group(1), self.domain, m.group(2), m.group(3)]) return rtn else: return &quot;&quot;.join([m.group(1), m.group(2), m.group(3)]) html = re.compile(pattern).sub(func, html) html = html_template.format(content=html) html = html.encode(&quot;utf-8&quot;) return html except Exception as e: logging.error(&quot;解析错误&quot;, exc_info=True) if __name__ == &#39;__main__&#39;: start_url = &quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; crawler = LiaoxuefengPythonCrawler(&quot;廖雪峰Git&quot;, start_url) crawler.run()","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://60ke.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python代码中func(*args, **kwargs)","date":"2017-04-21T20:10:00.000Z","path":"2017/04/22/Python代码中func(*args, **kwargs)/","text":"这个args其实是程序员对arguments的缩写，这种缩写可以说已经成为了一种传统（各种编程语言都这么做）；而argument的中文含义即为参数 这是Python函数可变参数 args及kwargs *args表示任何多个无名参数，它是一个tuple **kwargs表示关键字参数，它是一个dict 测试代码如下： def foo(*args,**kwargs): print &#39;args=&#39;,args print &#39;kwargs=&#39;,kwargs print &#39;**********************&#39; if __name__==&#39;__main__&#39;: foo(1,2,3) foo(a=1,b=2,c=3) foo(1,2,3,a=1,b=2,c=3) foo(1,&#39;b&#39;,&#39;c&#39;,a=1,b=&#39;b&#39;,c=&#39;c&#39;) 执行结果如下： args= (1, 2, 3) kwargs= &#123;&#125; ********************** args= () kwargs= &#123;&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2&#125; ********************** args= (1, 2, 3) kwargs= &#123;&#39;a&#39;: 1, &#39;c&#39;: 3, &#39;b&#39;: 2&#125; ********************** args= (1, &#39;b&#39;, &#39;c&#39;) kwargs= &#123;&#39;a&#39;: 1, &#39;c&#39;: &#39;c&#39;, &#39;b&#39;: &#39;b&#39;&#125; **********************","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"}]},{"title":"美股。。。","date":"2017-04-21T06:15:13.000Z","path":"2017/04/21/美股。。。/","text":"炒股几个月了，当时开始入手美股是看好京东，那时京东股票的价格在25-27之间吧，今天已经涨到34了，我入股的501美元外加送的100RMB和推荐老黄的200RMB本金大概在542$,然而现在看了本金在518，困于AMD，当时放了京东是觉得短期更挣钱，但是现在看来不如预想。 两次亏损一次是微博当时夜间看着微博疯长，因为看好微博的地位垄断，以及马上就要出财报，感觉会超出预期，所以以59$的价格买入，然而财报虽然超出华尔街预期，但是在财报出来的半月股价已经被炒到58多，利好已经被炒空，财报虽然超出华尔街预期，但是其实低于近半月股价期望，所以股价不升反降，而我以59的价格买入超出历史最高价格，上头的成分很大，因为本来看好，实时关注的时候看着股价疯长怕越来越高，没忍住冲动。。。后来想想很是后悔和不该，刚入股票一再告诫自己买涨不买跌，微博最近狂涨，再买风险较大，当然最主要的教训还是## 超出华尔街预期的财报未必会涨！！！ ## 第二次亏损，也就是现在这次AMD的，amd也是近一年狂涨的股价，但是因为最近产品（处理器）比较给力，外加相对于它的竞争对手Intel，NVIDIA来说它的价格过于便宜（性价比太高），当然更是因为我亲眼见过，当天AMD开盘降了10%之后一天之内扭跌为涨，让我觉得有部分强力资金在支撑，所以觉得比较稳当，当时时以13.7多买的目标价格15（接近历史最高，因为觉得AMD还是处于增长的，所以超越历史股价不是问题），之后不到一周的时间赚了20$左右，但是在14.2徘徊了一两天，因为学习原因没过多思考，然而突然遭遇暴跌百分之10左右。原因是分析师下调了AMD的目标股价，这下甩不出来了，过来一星期的今天亏损百分之6,7.觉得这次的教训，主要在于，扯的不够快，14.2其实也可以了，但是觉得放着也没啥问题，结果。。。## 见好就收 ## 两次盈利最开始27买了京东，之后京东开始跌到25因为长期看好的缘故，没卖，后来经过了漫长的恢复27又给卖了，算上交易费4$左右略亏了几块人民币（其实这次交易在我现在看来也是没错的当时京东长期徘徊在27左右股价比较稳定一时半会确实转不来钱），后来看准时机在微博45.5入手，然而在入手之后又跌到了42左右当时坚持没卖，两个月后以49.27的价格出售。虽然赚的不少但是时间太长49的价格虽然不少最高，但是我个人也是满意的。（别老想着抄底，最高卖）不过期间时间过长 第二次盈利，是在美国苹果状告高通导致高通股价大跌的时候，以52.82买入，目标价格57至少，后来看长期徘徊在56块多，以56.61的价格出售，期间经历20天。这次交易是最为满意的一次。没啥说的。 当时炒股算了每月增长%7每年就可以达到每年2.25的增长，10年3325的增长，本来以为很容易带到（其实现在也这么觉得），虽然现在实时并非如此，嗯 怎么说呢加油吧","tags":[]},{"title":"煎蛋爬虫分析比较总结","date":"2017-04-21T05:32:00.000Z","path":"2017/04/21/煎蛋爬虫分析比较总结/","text":"小甲鱼的爬虫 直接提取出用户正常访问页面的page![](https://ws1.sinaimg.cn/large/6cf740f6ly1feumgqfv6vj20a701qjra.jpg) 模块化结构代码易读性更高 模块化的代码利用率更高，可重复利用 目标：在精通Python之前每天坚持至少写一个爬虫，难度要越来越高","tags":[{"name":"总结","slug":"总结","permalink":"https://60ke.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"煎蛋模块化爬虫","date":"2017-04-21T04:46:00.000Z","path":"2017/04/21/煎蛋模块化爬虫/","text":"按照小甲鱼的Python课程打出来的，在find_imgs中添加了http:（未使用正则表达式） 煎蛋模块化爬虫import os import urllib.request def url_open(url): req = urllib.request.Request(url) req.add_header(&#39;User-Agent&#39;, &#39;&#39;) response = urllib.request.urlopen(url) html = response.read() return html def get_page(url): html = url_open(url).decode(&#39;utf-8&#39;) a = html.find(&#39;current-comment-page&#39;) + 23 b = html.find(&#39;]&#39;,a) return html[a:b] def find_imgs(url): html = url_open(url).decode(&#39;utf-8&#39;) img_addrs = [] a = html.find(&#39;img src=&#39;) while a != -1: b = html.find(&#39;.jpg&#39;, a, a+255) if b != -1: img_addrs.append(&#39;http:&#39;+html[a+9:b+4]) else: b =a + 9 a = html.find(&#39;img src=&#39;, b) return img_addrs def save_imgs(folder, img_addrs): for each in img_addrs: filename = each.split(&#39;/&#39;)[-1] with open(filename, &#39;wb&#39;) as f: img = url_open(each) f.write(img) def download_mm(folder= &#39;OOXX&#39;, pages=100): os.mkdir(folder) os.chdir(folder) url = &#39;http://jandan.net/ooxx/&#39; page_num = int(get_page(url)) for i in range(pages): page_num -=i page_url = url + &#39;page-&#39; +str(page_num) img_addrs = find_imgs(page_url) save_imgs(folder, img_addrs) download_mm()#//因为有默认参数所以（）可以为空，没有默认参数时不可以 find()用法：#!/usr/bin/python str1 = &quot;this is string example....wow!!!&quot; str2 = &quot;exam&quot; print (str1.find(str2)) print (str1.find(str2, 10)) print (str1.find(str2, 10,12)) print (str1.find(str2, 40)) 输出： 15 15 -1 -1","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://60ke.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"煎蛋网妹子图抓取","date":"2017-04-21T00:33:05.000Z","path":"2017/04/21/煎蛋网妹子图抓取/","text":"代码写的很烂，不过目的总算达到了 import requests from bs4 import BeautifulSoup import re import os i = 1 url = &#39;http://jandan.net/ooxx/page-&#39;+str(id)+&#39;#comments&#39; for id in range(200): res = requests.get(&#39;http://jandan.net/ooxx/page-&#39;+str(id)+&#39;#comments&#39;) #print(res) target_text = BeautifulSoup(res.text, &#39;html.parser&#39;) target_img = target_text.select(&#39;img&#39;) for img in target_img: img = str(img) img = re.findall(r&#39;&lt;img src=&quot;//(.+?)&quot;/&gt;&#39;,img) for picurl in img: picurl = &#39;http://&#39;+picurl print(&#39;正在下载第&#39;+i&#39;张图片&#39;) pic= requests.get(picurl) string = &#39;tupia\\\\&#39;+str(i) + &#39;.jpg&#39;##给要保存的文件命名（第一个&#39;\\&#39;是用来转义后面的&#39;\\&#39;，） fp = open(string,&#39;wb&#39;) fp.write(pic.content) fp.close() i += 1 “战果”：","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://60ke.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python 文件读写操作实例详解","date":"2017-04-21T00:23:00.000Z","path":"2017/04/21/Python 文件读写操作实例详解/","text":"脚本之家网上搜出来的，转给自己看 一、python中对文件、文件夹操作时经常用到的os模块和shutil模块常用方法。1.得到当前工作目录，即当前Python脚本工作的目录路径: os.getcwd()2.返回指定目录下的所有文件和目录名:os.listdir()3.函数用来删除一个文件:os.remove()4.删除多个目录：os.removedirs(r”c：\\python”)5.检验给出的路径是否是一个文件：os.path.isfile()6.检验给出的路径是否是一个目录：os.path.isdir()7.判断是否是绝对路径：os.path.isabs()8.检验给出的路径是否真地存:os.path.exists()9.返回一个路径的目录名和文件名:os.path.split()例子： os.path.split(&#39;/home/swaroop/byte/code/poem.txt&#39;) 结果：(&#39;/home/swaroop/byte/code&#39;, &#39;poem.txt&#39;) 10.分离扩展名：os.path.splitext()11.获取路径名：os.path.dirname()12.获取文件名：os.path.basename()13.运行shell命令: os.system()14.读取和设置环境变量:os.getenv() 与os.putenv()15.给出当前平台使用的行终止符:os.linesep Windows使用’\\r\\n’，Linux使用’\\n’而Mac使用’\\r’16.指示你正在使用的平台：os.name 对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’17.重命名：os.rename(old， new)18.创建多级目录：os.makedirs(r”c：\\python\\test”)19.创建单个目录：os.mkdir(“test”)20.获取文件属性：os.stat(file)21.修改文件权限与时间戳：os.chmod(file)22.终止当前进程：os.exit()23.获取文件大小：os.path.getsize(filename) 二、文件操作方法大全1.os.mknod(“test.txt”) 创建空文件2.fp = open(“test.txt”,w) 直接打开一个文件，如果文件不存在则创建文件3.关于open 模式： w：以写方式打开， a：以追加模式打开 (从 EOF 开始, 必要时创建新文件) r+：以读写模式打开 w+：以读写模式打开 (参见 w ) a+：以读写模式打开 (参见 a ) rb：以二进制读模式打开 wb：以二进制写模式打开 (参见 w ) ab：以二进制追加模式打开 (参见 a ) rb+：以二进制读写模式打开 (参见 r+ ) wb+：以二进制读写模式打开 (参见 w+ ) ab+：以二进制读写模式打开 (参见 a+ ) fp.read([size]) #size为读取的长度，以byte为单位fp.readline([size]) #读一行，如果定义了size，有可能返回的只是一行的一部分fp.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。fp.write(str) #把str写到文件中，write()并不会在str后加上一个换行符fp.writelines(seq) #把seq的内容全部写到文件中(多行一次性写入)。这个函数也只是忠实地写入，不会在每行后面加上任何东西。fp.close() #关闭文件。python会在一个文件不用后自动关闭文件，不过这一功能没有保证，最好还是养成自己关闭的习惯。 如果一个文件在关闭后还对其进行操作会产生ValueErrorfp.flush() #把缓冲区的内容写入硬盘fp.fileno() #返回一个长整型的”文件标签”fp.isatty() #文件是否是一个终端设备文件（unix系统中的）fp.tell() #返回文件操作标记的当前位置，以文件的开头为原点fp.next() #返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。fp.seek(offset[,whence]) #将文件打操作标记移到offset的位置。这个offset一般是相对于文件的开头来计算的，一般为正数。但如果提供了whence参数就不一定了，whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。需要注意，如果文件以a或a+的模式打开，每次进行写操作时，文件操作标记会自动返回到文件末尾。fp.truncate([size]) #把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。如果size比文件的大小还要大，依据系统的不同可能是不改变文件，也可能是用0把文件补到相应的大小，也可能是以一些随机的内容加上去。 三、目录操作方法大全1.创建目录 os.mkdir(&quot;file&quot;) 2.复制文件： shutil.copyfile(&quot;oldfile&quot;,&quot;newfile&quot;) #oldfile和newfile都只能是文件 shutil.copy(&quot;oldfile&quot;,&quot;newfile&quot;) #oldfile只能是文件夹，newfile可以是文件，也可以是目标目录 3.复制文件夹：4.shutil.copytree(&quot;olddir&quot;,&quot;newdir&quot;) #olddir和newdir都只能是目录，且newdir必须不存在5.重命名文件（目录） os.rename(&quot;oldname&quot;,&quot;newname&quot;) #文件或目录都是使用这条命令 6.移动文件（目录） shutil.move(&quot;oldpos&quot;,&quot;newpos&quot;) 7.删除文件 os.remove(&quot;file&quot;) 8.删除目录 os.rmdir(&quot;dir&quot;) #只能删除空目录 shutil.rmtree(&quot;dir&quot;) #空目录、有内容的目录都可以删 9.转换目录 os.chdir(&quot;path&quot;) #换路径 四、文件综合操作实例将文件夹下所有图片名称加上’_fc’python代码: # -*- coding:utf-8 -*- import re import os import time #str.split(string)分割字符串 #&#39;连接符&#39;.join(list) 将列表组成字符串 def change_name(path): global i if not os.path.isdir(path) and not os.path.isfile(path): return False if os.path.isfile(path): file_path = os.path.split(path) #分割出目录与文件 lists = file_path[1].split(&#39;.&#39;) #分割出文件与文件扩展名 file_ext = lists[-1] #取出后缀名(列表切片操作) img_ext = [&#39;bmp&#39;,&#39;jpeg&#39;,&#39;gif&#39;,&#39;psd&#39;,&#39;png&#39;,&#39;jpg&#39;] if file_ext in img_ext: os.rename(path,file_path[0]+&#39;/&#39;+lists[0]+&#39;_fc.&#39;+file_ext) i+=1 #注意这里的i是一个陷阱 #或者 #img_ext = &#39;bmp|jpeg|gif|psd|png|jpg&#39; #if file_ext in img_ext: # print(&#39;ok---&#39;+file_ext) elif os.path.isdir(path): for x in os.listdir(path): change_name(os.path.join(path,x)) #os.path.join()在路径处理上很有用 img_dir = &#39;D:\\\\xx\\\\xx\\\\images&#39; img_dir = img_dir.replace(&#39;\\\\&#39;,&#39;/&#39;) start = time.time() i = 0 change_name(img_dir) c = time.time() - start print(&#39;程序运行耗时:%0.2f&#39;%(c)) print(&#39;总共处理了 %s 张图片&#39;%(i)) 输出结果： 程序运行耗时:0.11 总共处理了 109 张图片 PS：输出指定文件夹下的所有文件名代码示例： import os dir = os.getcwd()+&quot;/data&quot; for i in os.walk(dir): for name in i[2]: print(name) python集合求差参考脚本之家http://www.jb51.net/article/56980.htm 正常的方式复制代码 代码如下: ret = [] for i in a: if i not in b: ret.append(i) 浓缩版复制代码 代码如下: ret = [ i for i in a if i not in b ] 另一版复制代码 代码如下: ret = list(set(a) ^ set(b)) 二. 获取两个list 的并集 复制代码 代码如下: print list(set(a).union(set(b))) 三. 获取两个 list 的差集复制代码 代码如下: print list(set(b).difference(set(a))) # b中有而a中没有的","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"}]},{"title":"爬取起点中文网月票榜前500名网络小说","date":"2017-04-19T03:10:25.000Z","path":"2017/04/19/爬取起点中文网月票榜前500名网络小说/","text":"‘’’ 参考自知乎https://zhuanlan.zhihu.com/p/26255754Talk is cheap ， show your code所需模块： requests padndas BeautifulSoup import requests from bs4 import BeautifulSoup import pandas newsary=[] for i in range(1,26): res=requests.get(&#39;http://r.qidian.com/yuepiao?chn=-1&amp;page=&#39;+str(i)) soup=BeautifulSoup(res.text,&#39;html.parser&#39;) for news in soup.select(&#39;.rank-view-list li&#39;): newsary.append(&#123;&#39;title&#39;:news.select(&#39;a&#39;)[1].text,&#39;name&#39;:news.select(&#39;a&#39;)[2].text,&#39;style&#39;:news.select(&#39;a&#39;)[3].text,&#39;describe&#39;:news.select(&#39;p&#39;)[1].text,&#39;lastest&#39;:news.select(&#39;p&#39;)[2].text,&#39;url&#39;:news.select(&#39;a&#39;)[0][&#39;href&#39;]&#125;) newsdf=pandas.DataFrame(newsary) newsdf.to_excel(&#39;qidiantop500.xlsx&#39;) 成果截图：","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://60ke.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Python正则表达式及列表与字符串的转换","date":"2017-04-19T01:19:00.000Z","path":"2017/04/19/Python正则表达式及列表与字符串的转换/","text":"Talk is cheap ， show you code import re hao = (&#39;&lt;h4&gt;&lt;a data-bid=&quot;1004608738&quot; data-eid=&quot;qd_C40&quot; href=&quot;//book.qidian.com/info/1004608738&quot; target=&quot;_blank&quot;&gt;圣墟&lt;/a&gt;&lt;/h4&gt;&#39;) target = re.findall(r&#39;target=&quot;_blank&quot;&gt;(.+?)&lt;/a&gt;&#39;, hao) print(target) print(type(target)) print (&quot;&quot;.join(target)) a = &#39;worileqing&#39; li = list(a) print(type(a)) print(type(a)) print(li) print(li[5]) 输出： [&#39;圣墟&#39;] &lt;class &#39;list&#39;&gt; 圣墟 &lt;class &#39;str&#39;&gt; &lt;class &#39;str&#39;&gt; [&#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;i&#39;, &#39;l&#39;, &#39;e&#39;, &#39;q&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;] e 参考： re.findall与re.compile测试代码 re.findallimport re a = &quot;wodiddjfkj&quot; b = re.findall(r&quot;d.+?k&quot;,a) c = re.findall(r&quot;d(.+?)k&quot;,a) print(b) print(c) 输出： [&#39;diddjfk&#39;] [&#39;iddjf&#39;] re.compileimport re a = &quot;wodiddjfkj&quot; b = re.compile(r&quot;d.+?k&quot;) c = b.findall(a) print(b) print(c) 输出： re.compile(&#39;d.+?k&#39;) [&#39;diddjfk&#39;] url解码：测试代码： import urllib.parse print(urllib.parse.unquote(&quot;%E6%B5%8B%E8%AF%95abc&quot;)) 输出： 测试abc url编码：测试代码： import urllib.parse print(urllib.parse.quote(&quot;测试abc&quot;)) 输出： %E6%B5%8B%E8%AF%95abc 补充用(.+?)来匹配任意字符中“.”是不包含/n的所以。。。解决办法：用([\\s\\S]*)来表示 bb = re.findall(&quot;2\\.([\\s\\S]*)&quot;,aa)) 表示的是匹配aa中”2.”之后的所有内容","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"},{"name":"正则","slug":"正则","permalink":"https://60ke.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"python之有道翻译","date":"2017-04-18T06:46:00.000Z","path":"2017/04/18/python之有道翻译/","text":"Talk is cheap ， show you code import urllib.request import urllib.parse import json import time &#39;&#39;&#39; head = &#123;&#125; head[&#39;User-Agent&#39;] = &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39; &#39;&#39;&#39; while True : content = input(&#39;输入要翻译的内容(输入q!退出程序)：&#39;) if content == &#39;q!&#39; : break url = &#39;http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=https://www.baidu.com/link&#39; data = &#123;&#125; data[&#39;type&#39;]= &#39;AUTO&#39; data[&#39;i&#39;] = content data[&#39;doctype&#39;] = &#39;json&#39; data[&#39;xmlVersion&#39;] = &#39;1.8&#39; data[&#39;keyfrom&#39;] = &#39;fanyi.web&#39; data[&#39;ue&#39;] =&#39;UTF-8&#39; data[&#39;action&#39;] =&#39;FY_BY_ENTER&#39; data[&#39;typoResult&#39;] =&#39;true&#39; data = urllib.parse.urlencode(data).encode(&#39;utf-8&#39;) req = urllib.request.Request(url,data) req.add_header(&#39;User-Agent&#39; , &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&#39;) response = urllib.request.urlopen(req) html = response.read().decode(&#39;utf-8&#39;) target = json.loads(html) print(&#39;翻译结果为：%s&#39; %target[&quot;translateResult&quot;][0][0][&quot;tgt&quot;]) time.sleep(1)","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"}]},{"title":"python基础之生成器，迭代器，高阶函数","date":"2017-04-18T00:31:00.000Z","path":"2017/04/18/python基础之生成器，迭代器，高阶函数/","text":"thumb,no 高阶函数def add(x,y,f): return f(x)+(y) add(3,(-4),abs)// 7 迭代器example:1 for i in range(5) print(i) 0 1 2 3 4 example:2 xinxi = &#123; &quot;name&quot; : &quot;60ke&quot;, &quot;age&quot; : &quot;23&quot;, &quot;hobby&quot; : &quot;challenge&quot; &#125; for each in xinxi: print(each,xinxi[each]) example:3 string = &quot;I Love Hard&quot; it = iter(string) while True: try: each = next(it) except StopIteration://notice Aa break print(each) //for each in string 生成器yield，相当于挂起的return def MYGEN(): print(&#39;生成器被执行！&#39;) yield 1 yield 2 mygen = MYGEN() 在yield1之前加入 return 0 测试 无限输出菲波那切数列： def fibs(): a=0 b=1 while True: a,b=b,a+b yield a for each in fibs(): print(each) 看图思考 a = &#123;s:s%3==0 for s in range(10)&#125; print(a) &#123;0: True, 1: False, 2: False, 3: True, 4: False, 5: False, 6: True, 7: False, 8: False, 9: True&#125; 暴走的括号：b = &#123;i for i in [1,1,12,3,2,23,3]&#125; c = &#123;i for i in (1,1,12,3,2,23,3)&#125; d = &#123;i for i in &#123;1,1,12,3,2,23,3&#125;&#125; f = (i for i in &#123;1,1,12,3,2,23,3&#125;) g = (i for i in (1,1,12,3,2,23,3)) h = (i for i in [1,1,12,3,2,23,3]) j = [i for i in (1,1,12,3,2,23,3)] k = [i for i in &#123;1,1,12,3,2,23,3&#125;] n = [i for i in [1,1,12,3,2,23,3]] print(b,c,d,f,g,h,j,k,n) 输出结果： &#123;1, 2, 3, 12, 23&#125; &#123;1, 2, 3, 12, 23&#125; &#123;1, 2, 3, 12, 23&#125; &lt;generator object &lt;genexpr&gt; at 0x0000000002BB3468&gt; &lt;generator object &lt;genexpr&gt; at 0x0000000002BB34C0&gt; &lt;generator object &lt;genexpr&gt; at 0x0000000002BB3518&gt; [1, 1, 12, 3, 2, 23, 3] [1, 2, 3, 12, 23] [1, 1, 12, 3, 2, 23, 3] &gt;&gt;&gt; &gt;&gt;&gt; f = (i for i in &#123;1,1,12,3,2,23,3&#125;) &gt;&gt;&gt; next(f) 1 &gt;&gt;&gt; next(f) 2 &gt;&gt;&gt; next(f) 3 &gt;&gt;&gt; next(f) 12 &gt;&gt;&gt; 总结:小括号与逗号可以创建生成器 [IMG]https://ws1.sinaimg.cn/large/6cf740f6ly1feqwzla4h6j20b60g0gls.jpg[/IMG]","tags":[{"name":"python","slug":"python","permalink":"https://60ke.github.io/tags/python/"}]},{"title":"django框架博客开发-3","date":"2017-04-10T01:18:20.000Z","path":"2017/04/10/django框架博客开发-3/","text":"创建应用 进入manage.py同级目录 命令行输入 python manage.py startapp blog 添加应用名到settings.py中的INATALLED_APPS里 目录结构 migrations数据移植（迁移）模块 admin.py该应用的后台管理系统配置 apps.py该应用的一些配置Django—1.9以后自动生成 models.py 数据模块使用orm框架类似于MVC结构中的Models test.py自动化测试模块Django提供了自动化测试功能在这里编写测试脚本（语句） views.py执行响应的代码所在模块代码逻辑处理的主要地点项目中大部分代码均在这里编写 创建第一个页面（响应）编辑blog.views添加以下代码 from django.http import HttpResponse def index(reques): return HttpResponse(&#39;Hello,World&#39;) 配置URL打开myblog下的urls.py 打开sever，在浏览器输入网址打开页面","tags":[]},{"title":"django框架博客开发-2","date":"2017-04-10T00:27:00.000Z","path":"2017/04/10/django框架博客开发-2/","text":"django的简单介绍 创建项目 django-admin startproject myblog//项目名称； manage.py子命令 python manage.py 启动服务器 python manage.py runserver 8000//端口可以自定义 myblog项目目录介绍myblog目录：项目的一个容器包含项目的最基本的一些配置目录名称不建议修改 wsgi.py WSGI(Python Web Server Gateway Interface)//Python服务网关接口Python应用于web服务器之间的接口 urls.py URL配置文件django项目中所有页面都需要我们自己配置其URL settings.py项目的总配置文件里面包含了数据库，web应用，时间等各种配置 import os Build paths inside the project like this: os.path.join(BASE_DIR, …)//项目根目录 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(file))) Quick-start development settings - unsuitable for productionSee https://docs.djangoproject.com/en/1.11/howto/deployment/checklist/SECURITY WARNING: keep the secret key used in production secret!//django项目自动生产的安全码，项目启动必不可少 SECRET_KEY = ‘1z*kh0w2bqn7kg)v#lv5xw4&amp;f2(19ckz-u=ci8)&amp;+(ow9i(6as’ SECURITY WARNING: don’t run with debug turned on in production!//debug实际应用需要关闭 DEBUG = True ALLOWED_HOSTS = []#允许访问网站的地址 Application definition INSTALLED_APPS = [ &#39;django.contrib.admin&#39;,#管理 &#39;django.contrib.auth&#39;,#认证 &#39;django.contrib.contenttypes&#39;,#内容类型 &#39;django.contrib.sessions&#39;,#session缓存 &#39;django.contrib.messages&#39;,#消息 &#39;django.contrib.staticfiles&#39;,#静态目录 ] MIDDLEWARE = [ #中间键，django自带的工具集 &#39;django.middleware.security.SecurityMiddleware&#39;, &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;, &#39;django.middleware.common.CommonMiddleware&#39;, &#39;django.middleware.csrf.CsrfViewMiddleware&#39;, &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;, &#39;django.contrib.messages.middleware.MessageMiddleware&#39;, &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;, ] ROOT_URLCONF = ‘myblog.urls’ #URL的根配置文件 TEMPLATES = [ #模版，在django里是一个个的html文件 &#123; &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;, &#39;DIRS&#39;: [], &#39;APP_DIRS&#39;: True, &#39;OPTIONS&#39;: &#123; &#39;context_processors&#39;: [ &#39;django.template.context_processors.debug&#39;, &#39;django.template.context_processors.request&#39;, &#39;django.contrib.auth.context_processors.auth&#39;, &#39;django.contrib.messages.context_processors.messages&#39;, ], &#125;, &#125;, ] WSGI_APPLICATION = ‘myblog.wsgi.application’ Databasehttps://docs.djangoproject.com/en/1.11/ref/settings/#databases DATABASES = { #数据库配置 &#39;default&#39;: &#123; &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;), &#125; } Password validationhttps://docs.djangoproject.com/en/1.11/ref/settings/#auth-password-validators AUTH_PASSWORD_VALIDATORS = [ #密码认证 &#123; &#39;NAME&#39;: &#39;django.contrib.auth.password_validation.UserAttributeSimilarityValidator&#39;, &#125;, &#123; &#39;NAME&#39;: &#39;django.contrib.auth.password_validation.MinimumLengthValidator&#39;, &#125;, &#123; &#39;NAME&#39;: &#39;django.contrib.auth.password_validation.CommonPasswordValidator&#39;, &#125;, &#123; &#39;NAME&#39;: &#39;django.contrib.auth.password_validation.NumericPasswordValidator&#39;, &#125;, ] Internationalizationhttps://docs.djangoproject.com/en/1.11/topics/i18n/ LANGUAGE_CODE = ‘en-us’ TIME_ZONE = ‘UTC’ USE_I18N = True USE_L10N = True USE_TZ = True Static files (CSS, JavaScript, Images)https://docs.djangoproject.com/en/1.11/howto/static-files/ STATIC_URL = ‘/static/‘ init.pypython中声明模块的文件内容默认为空","tags":[]},{"title":"django框架博客开发-1","date":"2017-04-09T23:28:00.000Z","path":"2017/04/10/django框架博客开发-1/","text":"环境搭建安装python python官网：https://www.python.org //实际环境python2.7.13 安装djangodjango官网：https://www.djangoproject.com安装命令 pip install Django==1.11","tags":[]},{"title":"电子商务网站开发-1-需求分析","date":"2017-04-09T04:30:00.000Z","path":"2017/04/09/电子商务网站开发-1-需求分析/","text":"功能分析 一丶前台 用户登录：验证用户登录输入的用户名和密码 用户注册：要求提供用户的详细资料 商品浏览：用户对本站提供的商品进行浏览 商品详情：查看商品的详细信息 二丶后台 管理员模块：添加管理员，管理员列表，编辑管理员信息，删除管理员 商品分类模块：添加分类，分类列表，编辑分类，删除分类 商品管理模块：添加商品，商品列表，编辑商品，删除商品 用户管理模块：添加用户，用户列表，编辑用户，删除用户 商品图片模块：添加文字水印，添加图片水印 性能需求数据精确度 在执行数据的增加、删除、修改操作时，不允许因为程序原因导致操作失败。 在执行数据增加时，不允许发生多增加或重复增加数据的情况。 在执行数据删除时，不允许发生多删除数据的情况。 在执行数据删除时，对有关联的数据要求删除完全，如不能删除，请给予提示。 在执行数据修改时，也要求保持对应的准确性。 时间特性 在管理员执行增加删除等操作时，数据库响应时间要求在2秒之内。 Web用户浏览时，页面响应时间要求在4秒之内。支持软件 客户端软件 操作系统：Windows7、Liunx、UNIX. 浏览器：IE、FireFox、Chrome等 服务器端软件操作系统：Windows NT / 2000 Server 或更高版本、Liunx、UNIX.Web服务器：Apache2.0以上版本。数据库产品：MYSQL5.0 以上版本。服务器脚本：PHP5.2以上版本","tags":[]},{"title":"搭建一个简易的成绩管理系统的数据库","date":"2017-04-08T03:21:00.000Z","path":"2017/04/08/搭建一个简易的成绩管理系统的数据库/","text":"搭建一个简易的成绩管理系统的数据库 介绍 现需要构建一个简易的成绩管理系统的数据库，来记录几门课程的学生成绩。数据库中有三张表分别用于记录学生信息、课程信息和成绩信息。 数据库表的数据如下： 学生表(student)：学生 id 、学生姓名和性别 课程表：课程 id 和课程名 成绩表：成绩 id 、学生 id 、课程 id 和分数 服务器中的 MySQL 还没有启动，请注意 MySQL 的 root 账户默认密码为空。 目标 1.MySQL 服务处于运行状态 2.新建数据库的名称为 gradesystem 3.gradesystem 包含三个表：student、course、mark； student 表包含3列：sid(主键)、sname、gender；course 表包含2列：cid(主键)、cname；mark 表包含4列：mid(主键)、sid、cid、score ，注意与其他两个表主键之间的关系。4.将上述表中的数据分别插入到各个表中 参考答案 1 CREATE DATABASE gradesystem; use gradesystem; CREATE TABLE student(sid INT(10) PRIMARY KEY, sname CHAR(20), gender ENUM(‘male’, ‘female’)); INSERT INTO student VALUES(1, ‘Tom’, ‘male’); INSERT INTO student VALUES(2, ‘Jack’, ‘male’); INSERT INTO student VALUES(3, ‘Rose’, ‘female’); CREATE TABLE course(cid INT(10) PRIMARY KEY, cname CHAR(20)); INSERT INTO course VALUES(1, ‘math’); INSERT INTO course VALUES(2, ‘physics’); INSERT INTO course VALUES(3, ‘chemistry’); CREATE TABLE mark( mid INT(10) PRIMARY KEY, sid INT(10), cid INT(10), CONSTRAINT sid_kf FOREIGN KEY (sid) REFERENCES student(sid), CONSTRAINT cid_kf FOREIGN KEY (cid) REFERENCES course(sid), score INT(10) ); INSERT INTO mark VALUES(1, 1, 1, 80); INSERT INTO mark VALUES(2, 2, 1, 85); INSERT INTO mark VALUES(3, 3, 1, 90); INSERT INTO mark VALUES(4, 1, 2, 60); INSERT INTO mark VALUES(5, 2, 2, 90); INSERT INTO mark VALUES(6, 3, 2, 75); INSERT INTO mark VALUES(7, 1, 3, 90); INSERT INTO mark VALUES(8, 2, 3, 75); INSERT INTO mark VALUES(9, 3, 3, 85); 2 sudo service mysql start mysql -u root show databases; create database gradesystem; use gradesystem; show tables; create table student-&gt;( sid int (10)PRIMARY KEY,-&gt;sname char(20),-&gt;gender char(5)); alter table studentalter column gender char(10)); create table course(cid int(10)primary key,cname char(20)); create table mark(mid int(10)primary key,sid int(10),cid int(10),score int(10),constraint sid_fk foreign key(sid) references student(sid)constraint cid_fk foreign key(cid) references course(cid)); insert into table student values(1,’tom’,’male’);insert into table student values(2,’jack’,’male’);insert into table student values(3,’rose’,’male’); insert into course values(1,’math’)insert into course values(2,’physics’);insert into course values(3,’chemistry’); insert into mark values(1,1,1,80);insert into mark values(2,2,1,85);insert into mark values(3,3,1,90);insert into mark values(4,1,2,60);insert into mark values(6,3,2,75);insert into mark values(7,1,3,95);insert into mark values(8,2,3,75);insert into mark values(9,3,3,85); select *from mark;","tags":[]},{"title":"laravel学习-1","date":"2017-04-06T06:49:48.000Z","path":"2017/04/06/laravel学习-1/","text":"laravel基础","tags":[]},{"title":"php面试题-1","date":"2017-04-05T23:05:00.000Z","path":"2017/04/06/php面试题-1/","text":"Ⅰ谈谈你对http协议的理解 1.首先http（超文本传输协议）其处于OSI7层模型中的应用层，OSI7层模型分别为应用层-》表示层-》会话层-》传输层-》网络层-》数据链路层-》物理层，对于这7层模型，我们应该大致的了解每一层是干嘛的，这个是必须的，在此就不一一说明。 2.http事物是指从客户端（IE）向服务器端发送http请求，再由服务器将响应的内容返发回给客户端的一个过程。 3.http链接是通过tcp链接，首先客户端会打开一条连向服务器端的链接，然后开始发送http请求，接着由服务器返发响应的内容，当客户端接受后就断开此链接，这样一次客户端与服务器端的通信就结束了。 4.http报文：由客户端向服务器端发送的http请求和从服务器端发送到客户端响应的内容都是http报文，其格式为：起始行、头部（HEAD）、主体(BODY对于报文的理解，在这里向大家推荐一个工具叫：fiddler。通过它可以详细的看到http报文的组成结构和具体的内容。 5.http中的方法分为5种：增（PUT）、删(DELETE)、改(POST)、查(GET)、HEAD 6.MIME（多用途网络邮箱扩展）类型：对象类型/特定子类型，如:image/png，通过fiddler可在http请求的起始行中看到。 7.发送http请求的目的是为了请求某一资源，然后由服务器返回客户端需要的资源，客户端（IE）通过解析将其显示出来，这里的资源是如何标识的呢？其实是通过URI(Uniform Resource Identifier)统一资源标识符，其主要有2中形式：URL（统一资源定位符）和URN（统一资源名称），目前最常用的是URL。 Ⅱ谈谈对ajax的理解Ajax的全称是Asynchronous JavaScript and XML 中文名称定义为异步的JavaScript和XML。ajax是JavaScript、XML、CSS、DOM等多种已有技术的组合，它可以实现客户端的异步请求操作，这样可以实现在不需要刷新页面的情况下与服务器进行通信，从而减少用户的等待时间。 Ⅲ谈谈对数据库事务的理解数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。 Ⅳ谈谈序列化的作用序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。序列化使其他代码可以查看或修改那些不序列化便无法访问的对象实例数据。确切地说，代码执行序列化需要特殊的权限：即指定了 SerializationFormatter 标志的 SecurityPermission。在默认策略下，通过 Internet 下载的代码或 Internet 代码不会授予该权限；只有本地计算机上的代码才被授予该权限。通常，对象实例的所有字段都会被序列化，这意味着数据会被表示为实例的序列化数据。这样，能够解释该格式的代码有可能能够确定这些数据的值，而不依赖于该成员的可访问性。类似地，反序列化从序列化的表示形式中提取数据，并直接设置对象状态，这也与可访问性规则无关。对于任何可能包含重要的安全性数据的对象，如果可能，应该使该对象不可序列化。如果它必须为可序列化的，请尝试生成特定字段来保存不可序列化的重要数据。如果无法实现这一点，则应注意该数据会被公开给任何拥有序列化权限的代码，并确保不让任何恶意代码获得该权限。 Ⅴ写出你所知道的数据库的优化方法1、创建索引对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。2、复合索引比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。3、索引不会包含有NULL值的列只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。4、使用短索引对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。5、排序的索引问题mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。6、like语句操作一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。7、不要在列上进行运算select * from users where YEAR(adddate)&lt;2007;将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成select * from users where adddate&lt;‘2007-01-01’;8、不使用NOT IN和&lt;&gt;操作NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。 Ⅵ写出你所知道的排序方法并说出他们的时间复杂度空间复杂度以及稳定性http://blog.chinaunix.net/attachment/201201/18/21457204_1326898064RUxx.jpg Ⅶ简述cookie和sessioncookie是一种在客户浏览器端存储数据并以此来跟踪和识别用户的机制。session 用来在服务器端保存用户的状态信息。cookie数据存放在客户的浏览器上，服务器端不用保存。session数据放在服务器上，本地内存也有一份。cookie安全性不如session。因为普通cookie保存在本地硬盘上，黑客可以伪造url等方式发起xss攻击，获取本地硬盘保存状态的cookie，进而窃取用户的敏感信息。session则不同，只有在用户登录此网站时发起xss攻击才能获取session信息，关闭浏览器之后，session即被销毁，安全性较cookie要好Cookie支持跨域名访问，Session仅在他所在的域名内有效。cookie的保存内容大小有限制。 Ⅷtcp与udp有什么差别，列举几个基于udp和tcp的协议TCP—传输控制协议,提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。UDP—用户数据报协议，是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快TCP是面向连接的，有比较高的可靠性，一些要求比较高的服务一般使用这个协议，如FTP、Telnet、SMTP、HTTP、POP3等，而UDP是面向无连接的，使用这个协议的常见服务有DNS、SNMP、QQ等。对于QQ必须另外说明一下，QQ2003以前是只使用UDP协议的，其服务器使用8000端口，侦听是否有信息传来，客户端使用4000端口，向外发送信息（这也就不难理解在一般的显IP的QQ版本中显示好友的IP地址信息中端口常为4000或其后续端口的原因了），即QQ程序既接受服务又提供服务，在以后的QQ版本中也支持使用TCP协议了。","tags":[]},{"title":"python爬取微博","date":"2017-04-05T07:22:00.000Z","path":"2017/04/05/python爬取微博/","text":"微博算是用的比较多了，但是一条一条的翻看太过于麻烦，无奈爬取之。 环境：win7+python2.7； python模块：request；bs4；beautifulsoup4；lxml； chrome浏览器 实现过程：获取cookie：打开chrome然后Ctrl+Shift+I调出开发者工具，点击tooggle device toolbar(Ctrl+shift+M)然后在Responsive选择合适的设备，我这里选择的是nexus5X，接下来打开weibo.com这时候应该看到的就是手机端网页的微博登录页面。在开发者工具中选中Network–Preserve log，然后登录微博。在开发者工具中找到有关m.weibo.cn的复制自己的cookie获取你想爬取微博的user_id：就是你要爬取的微博的主页网址中weibo.com/u/后面的数字部分开始利用python脚本爬取这是python程序的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#-*-coding:utf8-*-import reimport stringimport sysimport osimport urllibimport urllib2from bs4 import BeautifulSoupimport requestsfrom lxml import etreereload(sys) sys.setdefaultencoding(&#39;utf-8&#39;)if(len(sys.argv)&gt;&#x3D;2): user_id &#x3D; (int)(sys.argv[1])else: user_id &#x3D; (int)(raw_input(u&quot;请输入user_id: &quot;))cookie &#x3D; &#123;&quot;Cookie&quot;: &quot;#your cookie&quot;&#125;url &#x3D; &#39;http:&#x2F;&#x2F;weibo.cn&#x2F;u&#x2F;%d?filter&#x3D;1&amp;page&#x3D;1&#39;%user_idhtml &#x3D; requests.get(url, cookies &#x3D; cookie).contentselector &#x3D; etree.HTML(html)pageNum &#x3D; (int)(selector.xpath(&#39;&#x2F;&#x2F;input[@name&#x3D;&quot;mp&quot;]&#39;)[0].attrib[&#39;value&#39;])result &#x3D; &quot;&quot; urllist_set &#x3D; set()word_count &#x3D; 1image_count &#x3D; 1print u&#39;爬虫准备就绪...&#39;for page in range(1,pageNum+1): #获取lxml页面 url &#x3D; &#39;http:&#x2F;&#x2F;weibo.cn&#x2F;u&#x2F;%d?filter&#x3D;1&amp;page&#x3D;%d&#39;%(user_id,page) lxml &#x3D; requests.get(url, cookies &#x3D; cookie).content #文字爬取 selector &#x3D; etree.HTML(lxml) content &#x3D; selector.xpath(&#39;&#x2F;&#x2F;span[@class&#x3D;&quot;ctt&quot;]&#39;) for each in content: text &#x3D; each.xpath(&#39;string(.)&#39;) if word_count&gt;&#x3D;4: text &#x3D; &quot;%d :&quot;%(word_count-3) +text+&quot;\\n\\n&quot; else : text &#x3D; text+&quot;\\n\\n&quot; result &#x3D; result + text word_count +&#x3D; 1 #图片爬取 soup &#x3D; BeautifulSoup(lxml, &quot;lxml&quot;) urllist &#x3D; soup.find_all(&#39;a&#39;,href&#x3D;re.compile(r&#39;^http:&#x2F;&#x2F;weibo.cn&#x2F;mblog&#x2F;oripic&#39;,re.I)) first &#x3D; 0 for imgurl in urllist: urllist_set.add(requests.get(imgurl[&#39;href&#39;], cookies &#x3D; cookie).url) image_count +&#x3D;1fo &#x3D; open(&quot;&#x2F;Users&#x2F;Personals&#x2F;%s&quot;%user_id, &quot;wb&quot;)fo.write(result)word_path&#x3D;os.getcwd()+&#39;&#x2F;%d&#39;%user_idprint u&#39;文字微博爬取完毕&#39;link &#x3D; &quot;&quot;fo2 &#x3D; open(&quot;&#x2F;Users&#x2F;Personals&#x2F;%s_imageurls&quot;%user_id, &quot;wb&quot;)for eachlink in urllist_set: link &#x3D; link + eachlink +&quot;\\n&quot;fo2.write(link)print u&#39;图片链接爬取完毕&#39;if not urllist_set: print u&#39;该页面中不存在图片&#39;else: #下载图片,保存在当前目录的pythonimg文件夹下 image_path&#x3D;os.getcwd()+&#39;&#x2F;weibo_image&#39; if os.path.exists(image_path) is False: os.mkdir(image_path) x&#x3D;1 for imgurl in urllist_set: temp&#x3D; image_path + &#39;&#x2F;%s.jpg&#39; % x print u&#39;正在下载第%s张图片&#39; % x try: urllib.urlretrieve(urllib2.urlopen(imgurl).geturl(),temp) except: print u&quot;该图片下载失败:%s&quot;%imgurl x+&#x3D;1print u&#39;原创微博爬取完毕，共%d条，保存路径%s&#39;%(word_count-4,word_path)print u&#39;微博图片爬取完毕，共%d张，保存路径%s&#39;%(image_count-1,image_path) 可以将上面的代码保存为wb.py然后在cmd里面运行 1python wb.py 大功告成 ***2016/12/29 星期四 3:16:40 *** 补充：python模块的安装可以用easy_install的命令安装 例如 1easy_install lxml python模块pip安装：http://jingyan.baidu.com/article/e73e26c0d94e0524adb6a7ff.html用Python写一个简单的微博爬虫: http://www.jianshu.com/p/7c5a4d7545caMicrosoft Visual C++ Compiler for Python 2.7:http://www.microsoft.com/en-us/download/details.aspx?id=44266","tags":[]},{"title":"VMware安装MacOS","date":"2017-04-05T07:18:00.000Z","path":"2017/04/05/VMware安装MacOS /","text":"title: VMware安装MacOSdate: 2017-01-05 16:51:55tags: mac 准备工作：VMware12OX 10.12 Sierra镜像cdrUnlocker208–VMware上的Mac补丁（bios intelVT开启）工具地址：链接： http://pan.baidu.com/s/1nv0iiZB 密码：f1twVMware Workstation 12序列号: 5A02H-AU243-TZJ49-GTC7K-3C61N 安装过程 安装VMware 安装mac补丁解压unlocker208，右键win-install.cmd以管理员运行，然后等待cmd窗口自己关闭，unlocker208安装完成 安装VMware里面的mac上述工作准备完成后新建虚拟机里面就会多出Apple Mac OS X(M)选项，安转即可 不可恢复错误解决问题解决 mac安转完成打开出现提示不可恢复错误，此时进入虚拟机安装目录用记事本类的编辑器，编辑macOS 10.12.vmx加入以下代码：smc.version = &quot;0&quot; 完工 补充VMware优化：http://blog.csdn.net/whitehack/article/details/47074403/","tags":[]},{"title":"通过路由器自定义host与连接设备共享host","date":"2017-04-05T07:13:00.000Z","path":"2017/04/05/通过路由器自定义host与连接设备共享host/","text":"次奥 过程我的路由器是newifi现在刷的是Pandorabox是基于openwrt的路由系统，系统集成的dhcp/dns服务可以自定义host。用winscp连接路由上传我们的host文件到路由，然后在路由设置里的额外的hosts文件打钩，填入我们刚刚的host。然后ssh连接路由输入命令/etc/init.d/dnsmasq restartPs：如果是电脑本地的dns不能使用自定义的，需要改为路由器的dns，其实直接改为自动获取dns就行了。 host","tags":[]},{"title":"在github上搭建自己的博客","date":"2016-12-14T11:08:00.000Z","path":"2016/12/14/在github上搭建自己的博客/","text":"的","tags":[]},{"title":"服务器搬回国内了","date":"2016-12-13T09:37:15.000Z","path":"2016/12/13/服务器搬回国内了/","text":"网站备案通过了放回国内","tags":[]},{"title":"PHP常用类库","date":"2016-03-05T21:50:00.000Z","path":"2016/03/06/PHP常用类库/","text":"PHP常用类库 数组类 class libArray{ /** * 多维数组合并 * @return array */ public static function merge () { $args = func_get_args(); $array = []; foreach ( $args as $arg ) { if ( is_array($arg) ) { foreach ( $arg as $k =&gt; $v ) { if ( is_array($v) ) { $array[$k] = isset($array[$k]) ? $array[$k] : []; $array[$k] = self::merge($array[$k], $v); } else { $array[$k] = $v; } } } } return $array; } /** * 多维to一维 * [1=&gt;[&#39;a&#39;=&gt;&#39;v1&#39;]] to [&#39;1|a&#39;=&gt;&#39;v1&#39;] * @param array $array * @param string $delimiter * @param string $key * @return array */ public static function mTo1 (array $array, $delimiter = &#39;|&#39;, $key = &#39;&#39;) &#123; $data = []; if ( !is_array($array) ) &#123; return $data; &#125; foreach ( $array as $k =&gt; $v ) &#123; $keyNew = trim($key.$delimiter.$k, $delimiter); if ( is_array($v) ) &#123; $data = array_merge($data, self::mTo1($v, $delimiter, $keyNew)); &#125; else &#123; $data[$keyNew] = $v; &#125; &#125; return $data; &#125; /** * 数组排序 * @param array $array * @param $column * @param bool $reverse * @return bool */ public static function sort (array &amp;$array, $column, $reverse = FALSE) &#123; $arrColumn = []; foreach ( $array as $key =&gt; $val ) &#123; $arrColumn[$key] = $val[$column]; &#125; return array_multisort($arrColumn, $reverse ? SORT_DESC : SORT_ASC, $array); &#125; /** * 添加索引 * @param array $array * @param $key * @return array */ public static function index (array $array, $key) &#123; $ret = []; foreach ( $array as $val ) &#123; $ret[$val[$key]] = $val; &#125; return $ret; &#125; /** * 添加前后缀 * @param $array * @param null $pre * @param null $suf * @return array */ public static function addFix (array $array, $pre = NULL, $suf = NULL) &#123; $ret = []; foreach ( $array as $key =&gt; $val ) &#123; $ret[$key] = $pre.$val.$suf; &#125; return $ret; &#125; }数据检查类 class libCheck{ /** * 是否为IP（IPv4） * @param $ip * @return bool */ public static function isIP ($ip) { $isIP = filter_var($ip, FILTER_VALIDATE_IP) ? TRUE : FALSE; return $isIP; } /** * 是否为邮箱地址 * @param $mail * @return bool */ public static function isMail ($mail) &#123; $isMail = filter_var($mail, FILTER_VALIDATE_EMAIL) ? TRUE : FALSE; return $isMail; &#125; /** * 是否为URL * @param $url * @return bool */ public static function isURL ($url) &#123; $isMail = filter_var($url, FILTER_VALIDATE_URL) ? TRUE : FALSE; return $isMail; &#125; /** * 是否为正整数 * @param $num * @return bool */ public static function isPosiInt ($num) &#123; $isPosiInt = is_int($num) &amp;&amp; $num &gt; 0; return $isPosiInt; &#125; /** * 是否在范围内 * @param $num * @param int $min * @param null $max * @return bool */ public static function isBetween ($num, $min = 0, $max = NULL) &#123; $isBetween = $num &gt;= $min; if ( $max ) &#123; $isBetween = $isBetween &amp;&amp; $num &lt;= $max; &#125; return $isBetween; &#125; /** * 是否为有效长度 * @param $str * @param int $min * @param null $max * @return bool */ public static function isValidLen ($str, $min = 1, $max = NULL) &#123; $length = mb_strlen($str); $isValidLen = self::isBetween($length, $min, $max); return $isValidLen; &#125; }文件类 class libFile{ /** * 获取目录下所有文件 * @param $path * @return array */ public static function getFiles ($path) { $path = self::formatePath($path); if (!is_dir($path)) { return []; } $dh = opendir($path); $files = []; while ( ($filename = readdir($dh)) !== FALSE ) { if ( $filename != ‘.’ &amp;&amp; $filename != ‘..’ ) { $files[] = implode(‘/‘, [$path, $filename]); } } closedir($dh); return $files; } /** * 按模式取目录下文件 * @param $path * @param $pattern * @return array */ public static function getFilesByPattern ($path, $pattern) &#123; $path = self::formatePath($path); $filePattern = sprintf(&#39;%s/%s&#39;, $path, $pattern); return glob($filePattern); &#125; /** * 递归删除文件夹 * @param $dir * @return bool */ public static function rmDir($dir) &#123; $dir = self::formatePath($dir); $dh = opendir($dir); while ($filename = readdir($dh)) &#123; if ($filename != &#39;.&#39; &amp;&amp; $filename != &#39;..&#39;) &#123; $path = sprintf(&#39;%s/%s&#39;, $dir, $filename); is_dir($path) ? self::rmDir($path) : unlink($path); &#125; &#125; closedir($dh); return rmdir($dir); &#125; /** * 获取最后修改时间 * @param $path * @return int */ public static function getModifiedTime ($path) &#123; return filemtime($path); &#125; /** * 格式化路径 * @param $path * @return string */ public static function formatePath ($path) &#123; return rtrim($path, &#39;/&#39;); &#125; }HTTP类 class libHttp{ /** * GET方法 * @param $url * @param array $options * @return bool|mixed */ public static function get ($url, $options = []) { return self::send($url, NULL, NULL, $options); } /** * POST方法 * @param $url * @param array $params * @param array $options * @return bool|mixed */ public static function post ($url, $params = [], $options = []) &#123; return self::send($url, &#39;POST&#39;, $params, $options); &#125; /** * @param $url * @param string $method * @param array $params * @param array $options * @return mixed|string */ public static function send ($url, $method = &#39;GET&#39;, $params = [], $options = []) &#123; $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 30); if ($method == &#39;POST&#39;) &#123; $options[CURLOPT_POST] = TRUE; $options[CURLOPT_POSTFIELDS] = $params; &#125; curl_setopt_array($ch, $options); $result = curl_exec($ch); return curl_errno($ch) ? curl_error($ch) : $result; &#125; }字符串类 class libString{ /** * 随机字符串 * @param int $length * @param bool $num * @param bool $lower * @param bool $upper * @return string */ public static function rand ($length=5, $num=TRUE, $lower=TRUE, $upper=TRUE) { $str = ‘’; $num &amp;&amp; $str .= ‘0123456789’; $lower &amp;&amp; $str .= ‘abcdefghijklmnopqrstuvwxyz’; $upper &amp;&amp; $str .= ‘ABCDEFGHIJKLMNOPQRSTUVWXYZ’; $rand = substr(str_shuffle($str), -$length); return $rand; } /** * 字符串截取（单次） * @param $ld * @param $rd * @param $str * @return string */ public static function sub ($ld, $rd, $str) &#123; $start = strpos($str, $ld) + strlen($ld); $end = strpos($str, $rd, $start); $data = substr($str, $start, $end - $start); return $data; &#125; /** * 字符串截取（批量） * @param $ld * @param $rd * @param $str * @return array */ public static function subs ($ld, $rd, $str) &#123; $data = []; $lLen = strlen($ld); $rLen = strlen($rd); $offset = 0; while ( ($start = strpos($str, $ld, $offset)) !== FALSE ) &#123; $start += $lLen; $end = strpos($str, $rd, $start); $data[] = substr($str, $start, $end - $start); $offset = $end + $rLen; &#125; return $data; &#125; /** * 生成唯一ID * @return string */ public static function uniqid () &#123; return md5(uniqid(rand(), true)); &#125; }其它工具类 class libTool{ /** * ip-&gt;int * @param $ip * @return string */ public static function ip2long ($ip) { $long = sprintf(‘%u’, ip2long($ip)); return $long; } /** * 系统负载 * @return mixed */ public static function loadAvg () &#123; $load = sys_getloadavg()[0]; return $load; &#125; /** * 写日志文件 * @param $file * @param $msg * @param bool $newLine */ public static function log ($file, $msg, $newLine = TRUE) &#123; $newLine &amp;&amp; $msg .= &quot;\\n&quot;; file_put_contents($file, $msg, FILE_APPEND); &#125; /** * 内存使用峰值(M) * @return float */ public static function memoryUsage () &#123; $memory = memory_get_peak_usage(TRUE) / pow(1024, 2); $memory = round($memory, 2); return $memery; &#125; /** * 浏览器变量输出 * @param $var * @param bool|FALSE $return * @param bool|TRUE $strict * @return bool|mixed|string */ public static function dump ($var, $return = FALSE, $strict = TRUE) &#123; if (!$strict) &#123; if (ini_get(&#39;html_errors&#39;)) &#123; $output = print_r($var, TRUE); $output = sprintf(&#39;&lt;pre&gt;%s&lt;/pre&gt;&#39;, htmlspecialchars($output, ENT_QUOTES)); &#125; else &#123; $output = print_r($var, TRUE); &#125; &#125; else &#123; ob_start(); var_dump($var); $output = ob_get_clean(); if (!extension_loaded(&#39;xdebug&#39;)) &#123; $output = preg_replace(&#39;/\\]\\=\\&gt;\\n(\\s+)/m&#39;, &#39;] =&gt; &#39;, $output); $output = sprintf(&#39;&lt;pre&gt;%s&lt;/pre&gt;&#39;, htmlspecialchars($output, ENT_QUOTES)); &#125; &#125; if ($return) &#123; return $output; &#125; else &#123; echo $output; return TRUE; &#125; &#125; }","tags":[]},{"title":"微信二维码技术原理","date":"2016-02-09T19:05:00.000Z","path":"2016/02/10/微信二维码技术原理/","text":"微信扫描二维码登录网站 网站应用微信登录开发指南 微信扫描二维码登录网站是微信开放平台下网站应用的一种接口实现的功能。微信开放平台的网址是 https://open.weixin.qq.com 准备工作网站应用微信登录是基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。 在进行微信OAuth2.在进行微信OAuth2.0授权登录接入之前，在微信开放平台注册开发者帐号，并拥有一个已审核通过的网站应用，并获得相应的AppID和AppSecret，申请微信登录且通过审核后，可开始接入流程。 授权流程说明微信OAuth2.0授权登录让微信用户使用微信身份安全登录第三方应用或网站，在微信用户授权登录已接入微信OAuth2.0的第三方应用后，第三方可以获取到用户的接口调用凭证（access_token），通过access_token可以进行微信开放平台授权关系接口调用，从而可实现获取微信用户基本开放信息和帮助用户实现基础开放功能等。 微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为： 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数； 通过code参数加上AppID和AppSecret等，通过API换取access_token； 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。获取access_token时序图： 第一步：请求CODE第三方使用网站应用授权登录前请注意已获取相应网页授权作用域（scope=snsapi_login），则可以通过在PC端打开以下链接：https://open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 若提示“该链接无法访问”，请检查参数是否填写错误，如redirect_uri的域名与审核时填写的授权域名不一致或scope不为snsapi_login。 参数说明参数 是否必须 说明appid 是 应用唯一标识redirect_uri 是 重定向地址，需要进行UrlEncoderesponse_type 是 填codescope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可state 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击（跨站请求伪造攻击），建议第三方带上该参数，可设置为简单的随机数加session进行校验返回说明用户允许授权后，将会重定向到redirect_uri的网址上，并且带上code和state参数 redirect_uri?code=CODE&amp;state=STATE若用户禁止授权，则重定向后不会带上code参数，仅会带上state参数 redirect_uri?state=STATE请求示例登录一号店网站应用 https://passport.yhd.com/wechat/login.do 打开后，一号店会生成state参数，跳转到https://open.weixin.qq.com/connect/qrconnect?appid=wxbdc5610cc59c1631&amp;redirect_uri=https%3A%2F%2Fpassport.yhd.com%2Fwechat%2Fcallback.do&amp;response_type=code&amp;scope=snsapi_login&amp;state=3d6be0a4035d839573b04816624a415e#wechat_redirect 微信用户使用微信扫描二维码并且确认登录后，PC端会跳转到 https://passport.yhd.com/wechat/callback.do?code=CODE&amp;state=3d6be0a4035d839573b04816624a415e 为了满足网站更定制化的需求，我们还提供了第二种获取code的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过JS将code返回给网站。 JS微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。 网站内嵌二维码微信登录JS实现办法： 步骤1：在页面中先引入如下JS文件（支持https）： 步骤2：在需要使用微信登录的地方实例以下JS对象： var obj = new WxLogin({ id:”login_container”, appid: “”, scope: “”, redirect_uri: “”, state: “”, style: “”, href: “” });参数说明参数 是否必须 说明id 是 第三方页面显示二维码的容器idappid 是 应用唯一标识，在微信开放平台提交应用审核通过后获得scope 是 应用授权作用域，拥有多个作用域用逗号（,）分隔，网页应用目前仅填写snsapi_login即可redirect_uri 是 重定向地址，需要进行UrlEncodestate 否 用于保持请求和回调的状态，授权请求后原样带回给第三方。该参数可用于防止csrf攻击style 否 提供”black”、”white”可选，默认为黑色文字描述。详见文档底部FAQhref 否 自定义样式链接，第三方可根据实际需求覆盖默认样式。详见文档底部FAQ第二步：通过code获取access_token通过code获取access_token https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code参数说明参数 是否必须 说明appid 是 应用唯一标识，在微信开放平台提交应用审核通过后获得secret 是 应用密钥AppSecret，在微信开放平台提交应用审核通过后获得code 是 填写第一步获取的code参数grant_type 是 填authorization_code返回说明正确的返回： {“access_token”:”ACCESS_TOKEN”,“expires_in”:7200,“refresh_token”:”REFRESH_TOKEN”,“openid”:”OPENID”,“scope”:”SCOPE”}参数 说明access_token 接口调用凭证expires_in access_token接口调用凭证超时时间，单位（秒）refresh_token 用户刷新access_tokenopenid 授权用户唯一标识scope 用户授权的作用域，使用逗号（,）分隔错误返回样例： {“errcode”:40029,”errmsg”:”invalid code”}刷新access_token有效期access_token是调用授权关系接口的调用凭证，由于access_token有效期（目前为2个小时）较短，当access_token超时后，可以使用refresh_token进行刷新，access_token刷新结果有两种： 若access_token已超时，那么进行refresh_token会获取一个新的access_token，新的超时时间； 若access_token未超时，那么进行refresh_token不会改变access_token，但超时时间会刷新，相当于续期access_token。refresh_token拥有较长的有效期（30天），当refresh_token失效的后，需要用户重新授权。 请求方法获取第一步的code后，请求以下链接进行refresh_token： https://api.weixin.qq.com/sns/oauth2/refresh_token?appid=APPID&amp;grant_type=refresh_token&amp;refresh_token=REFRESH_TOKEN参数说明参数 是否必须 说明appid 是 应用唯一标识grant_type 是 填refresh_tokenrefresh_token 是 填写通过access_token获取到的refresh_token参数返回说明正确的返回： {“access_token”:”ACCESS_TOKEN”,“expires_in”:7200,“refresh_token”:”REFRESH_TOKEN”,“openid”:”OPENID”,“scope”:”SCOPE”}参数 说明access_token 接口调用凭证expires_in access_token接口调用凭证超时时间，单位（秒）refresh_token 用户刷新access_tokenopenid 授权用户唯一标识scope 用户授权的作用域，使用逗号（,）分隔错误返回样例： {“errcode”:40030,”errmsg”:”invalid refresh_token”}第三步：通过access_token调用接口获取access_token后，进行接口调用，有以下前提： access_token有效且未超时； 微信用户已授权给第三方应用帐号相应接口作用域（scope）。对于接口作用域（scope），能调用的接口有以下： 授权作用域（scope） 接口 接口说明snsapi_base /sns/oauth2/access_token 通过code换取access_token、refresh_token和已授权scope/sns/oauth2/refresh_token 刷新或续期access_token使用/sns/auth 检查access_token有效性snsapi_userinfo /sns/userinfo 获取用户个人信息其中snsapi_base属于基础接口，若应用已拥有其它scope权限，则默认拥有snsapi_base的权限。使用snsapi_base可以让移动端网页授权绕过跳转授权登录页请求用户授权的动作，直接跳转第三方网页带上授权临时票据（code），但会使得用户已授权作用域（scope）仅为snsapi_base，从而导致无法获取到需要用户授权才允许获得的数据和基础功能。 接口调用方法可查阅《微信授权关系接口调用指南》 F.A.Q 什么是授权临时票据（code）？答：第三方通过code进行获取access_token的时候需要用到，code的超时时间为10分钟，一个code只能成功换取一次access_token即失效。code的临时性和一次保障了微信授权登录的安全性。第三方可通过使用https和state参数，进一步加强自身授权登录的安全性。 什么是授权作用域（scope）？答：授权作用域（scope）代表用户授权给第三方的接口权限，第三方应用需要向微信开放平台申请使用相应scope的权限后，使用文档所述方式让用户进行授权，经过用户授权，获取到相应access_token后方可对接口进行调用。 网站内嵌二维码微信登录JS代码中style字段作用？答：第三方页面颜色风格可能为浅色调或者深色调，若第三方页面为浅色背景，style字段应提供”black”值（或者不提供，black为默认值），则对应的微信登录文字样式为黑色。相关效果如下： 若提供”white”值，则对应的文字描述将显示为白色，适合深色背景。相关效果如下： 4.网站内嵌二维码微信登录JS代码中href字段作用？答：如果第三方觉得微信团队提供的默认样式与自己的页面样式不匹配，可以自己提供样式文件来覆盖默认样式。举个例子，如第三方觉得默认二维码过大，可以提供相关css样式文件，并把链接地址填入href字段 .impowerBox .qrcode {width: 200px;}.impowerBox .title {display: none;}.impowerBox .info {width: 200px;}.status_icon {display：none}.impowerBox .status {text-align: center;}相关效果如下： ============================================","tags":[]},{"title":"python web服务器nginx+uwsgi+web.py的搭建","date":"2016-02-08T20:37:00.000Z","path":"2016/02/09/python web服务器nginx+uwsgi+web.py的搭建/","text":"1、环境配置python至少升级到2.6.6版本安装nginx #rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm #yum install nginx 安装MySQL数据库 #yum -y install mysql mysql-server mysql-devel libdbi-dbd-mysql #service mysqld start #chkconfig mysqld on 安装MySQLdb ( mysql-python ) #easy_install mysql-python 安装web.py ( 官网 ) #easy_install web.py 安装uwsgi ( 官网 ) #easy_install uwsgi 2、 配置uwsgiuwsgi 的配置文件 可支持xml yaml ini等格式。这里使用ini格式的配置文件。默认路径为/etc/uwsgi.ini。 [uwsgi] #使用动态端口，启动后将端口号写入以下文件中 socket = /tmp/uwsgi_vhosts.sock #也可以指定使用固定的端口 #socket=127.0.0.1:9090 pidfile=/var/run/uwsgi.pid daemonize=/var/log/uwsgi.log master=true vhost=true gid=root uid=root #性能相关的一些参数，具体内容查看官网文档 workers=10 max-requests=5000 limit-as=512 3、 创建uwsgi开机自启动脚本，便于进行系统管理 vi /etc/init.d/uwsgi，内容如下： #! /bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin DESC=&quot;uwsgi daemon&quot; NAME=uwsgi DAEMON=/usr/bin/uwsgi CONFIGFILE=/etc/$NAME.ini PIDFILE=/var/run/$NAME.pid SCRIPTNAME=/etc/init.d/$NAME set -e [ -x &quot;$DAEMON&quot; ] || exit 0 do_start() &#123; $DAEMON $CONFIGFILE || echo -n &quot;uwsgi already running&quot; &#125; do_stop() &#123; $DAEMON --stop $PIDFILE || echo -n &quot;uwsgi not running&quot; rm -f $PIDFILE echo &quot;$DAEMON STOPED.&quot; &#125; do_reload() &#123; $DAEMON --reload $PIDFILE || echo -n &quot;uwsgi can&#39;t reload&quot; &#125; do_status() &#123; ps aux|grep $DAEMON &#125; case &quot;$1&quot; in status) echo -en &quot;Status $NAME: \\n&quot; do_status ;; start) echo -en &quot;Starting $NAME: \\n&quot; do_start ;; stop) echo -en &quot;Stopping $NAME: \\n&quot; do_stop ;; reload|graceful) echo -en &quot;Reloading $NAME: \\n&quot; do_reload ;; *) echo &quot;Usage: $SCRIPTNAME &#123;start|stop|reload&#125;&quot; &gt;&amp;2 exit 3 ;; esac exit 0 将脚本属性修改为可执行： #chmod 755 /etc/init.d/uwsgi 启用开机自动启动： #chkconfig uwsgi on 启动uwsgi服务： #service uwsgi start 4、 配置nginx下的uwsgi站点 例如新增以下一个站点uwsgi。 vi /etc/nginx/conf.d/uwsgi.conf, 内容： server &#123; listen 9091; server_name localhost; root /www/uwsgi; index index.html index.htm; access_log logs/uwsgi.log; error_log logs/uwsgi.log; location / &#123; #使用动态端口 uwsgi_pass unix:///tmp/uwsgi_vhosts.sock; #uwsgi_pass 127.0.0.1:9090; include uwsgi_params; uwsgi_param UWSGI_SCRIPT index; #默认载入的脚本文件 uwsgi_param UWSGI_PYHOME $document_root; uwsgi_param UWSGI_CHDIR $document_root; &#125; &#125; 启动Nginx服务 #service nginx start #chkconfig nginx on 5、编写Hello Word！ #vim index.py 脚本名称和上面nginx虚机配置的uwsgi_param UWSGI_SCRIPT参数要一致 不使用web.py框架的写法： 01 #!/usr/bin/python 02 import os 03 import sys 06 def application(environ, start_response): 07 status = &#39;200 OK&#39; 08 output = &#39;Hello World!&#39; 09 response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;), 10 (&#39;Content-Length&#39;, str(len(output)))] 11 start_response(status, response_headers) 12 return [output] 使用web.py框架的写法： #!/usr/bin/env python # -*- coding: utf-8 -*- import web urls = ( &#39;/t&#39;, &#39;test&#39;, #测试 &#39;/&#39;, &#39;home&#39; ) app = web.application(urls, globals()) #返回wsgi接口，application 是 wsgi app入口函数 application = app.wsgifunc() class test: &#39;测试&#39; def GET(self): # 开发测试用 referer = web.ctx.env.get(&#39;HTTP_REFERER&#39;, &#39;http://google.com&#39;) client_ip = web.ctx.env.get(&#39;REMOTE_ADDR&#39;) host = web.ctx.env.get(&#39;host&#39;) fullpath = web.ctx.fullpath user_agent = web.ctx.env.get(&#39;HTTP_USER_AGENT&#39;) data = &quot;&quot; data += &#39;Client: %s&lt;br/&gt;\\n&#39; % client_ip data += &#39;User-agent: %s&lt;br/&gt;\\n&#39; % user_agent data += &#39;FullPath: %s&lt;br/&gt;\\n&#39; % fullpath data += &#39;Referer: %s&lt;br/&gt;\\n&#39; % referer return data def POST(self): pass class home: &#39;根目录请求的处理&#39; def GET(self): return &quot;Hello Web.py&quot; def POST(self): return self.GET() #定义404错误显示内容 def notfound(): return web.notfound(&quot;Sorry, the page you were looking for was not found.&quot;) app.notfound = notfound if __name__ == &quot;__main__&quot;: app.run() 6、重新载入python脚本 #service uwsgi reload 或者 #python index.py 9092 表示使用index.py脚本在9092端口新开启一个web服务监听这样你写的hello word就生效了，现在可以在浏览器输入你的ip地址+端口来访问python web内容了","tags":[]},{"title":"微信公众号开发-1","date":"2016-01-24T07:06:00.000Z","path":"2016/01/24/微信公众号开发-1/","text":"注册微信公众平台账号微信公众平台:https://mp.weixin.qq.com/ 注: 目前一张身份证只能注册两个账号，账号名称关乎加V认证，请慎重注册。 申请服务器/虚拟主机没有服务器/虚拟主机的童鞋可以使用BAE和SAE，不多介绍。 开启开发者模式微信公众平台有两个模式，一个是编辑模式（傻瓜模式），简单但功能单一。另一个是开发者模式，可以通过开发实现复杂功能。两个模式互斥，显而易见，登录微信公众平台并通过“高级功能”菜单开启开发者模式。 填写接口配置信息同样是在“高级功能”菜单中配置，需要配置两项参数:URL: 开发者应用访问地址，目前仅支持80端口，以“http://www.worileqing.top/weixin/index.php”为例。TOKEN: 随意填写，用于生成签名，以“YoonPer”为例。填写完把下面代码保存为index.php并上传至http://www.worileqing.top/weixin/目录，最后点击“提交”完成验证。01valid(); 05 class wechat { 06 public function valid() { 07 $echoStr = $_GET[\"echostr\"]; 08 if($this->checkSignature()){ 09 echo $echoStr; 10 exit; 11 } 12 } 13 14 private function checkSignature() {15 $signature = $_GET[“signature”];16 $timestamp = $_GET[“timestamp”];17 $nonce = $_GET[“nonce”];18 $token = TOKEN;19 $tmpArr = array($token, $timestamp, $nonce);20 sort($tmpArr);21 $tmpStr = implode( $tmpArr );22 $tmpStr = sha1( $tmpStr );23 if( $tmpStr == $signature ) {24 return true;25 } else {26 return false;27 }28 }29}30?&gt;这玩意儿就是微信公众平台校验URL是否正确接入，研究代码没有实质性意义，验证完即可删除文件，就不详细说明了，有兴趣的童鞋可以查看官方文档。微信公众平台API文档:http://mp.weixin.qq.com/wiki/index.php 开发微信公众平台功能OK，上面提到了，微信公众平台与开发者之间的数据交互是通过XML完成的，既然用到XML，当然得遵循规范，所以在着手开发之前先看看官方接口文档提供的XML规范，以文本消息为例: 当用户向微信公众账号发送消息时，微信服务器会POST给开发者一些数据:0102 0304 0506 071234567808 09&lt;![CDATA1]&gt;10 1112 13123456789012345614 开发者在处理完消息后需要返回数据给微信服务器:0102 0304 0506 071234567808 09&lt;![CDATA1]&gt;10 1112 13014除文本消息外，微信公众平台还支持用户发送图片消息、地理位置消息、链接消息、事件推送，而开发者还可以向微信公众平台回复音乐消息和图文消息，各类消息XML规范也可以参见官方文档。 来看看官方提供的一个PHP示例，我做了一些精简:01&lt;?php02$wechatObj = new wechat();03$wechatObj-&gt;responseMsg();04class wechat {05 public function responseMsg() {06 07 //———- 接 收 数 据 ———- //08 09 $postStr = $GLOBALS[“HTTP_RAW_POST_DATA”]; //获取POST数据10 11 //用SimpleXML解析POST过来的XML数据12 $postObj = simplexml_load_string($postStr,’SimpleXMLElement’,LIBXML_NOCDATA);13 14 $fromUsername = $postObj-&gt;FromUserName; //获取发送方帐号（OpenID）15 $toUsername = $postObj-&gt;ToUserName; //获取接收方账号16 $keyword = trim($postObj-&gt;Content); //获取消息内容17 $time = time(); //获取当前时间戳18 19 20 //———- 返 回 数 据 ———- //21 22 //返回消息模板23 $textTpl = “24 25 26 %s27 28 29 030 “;31 32 $msgType = “text”; //消息类型33 $contentStr = ‘http://www.worileqing.top&#39;; //返回消息内容34 35 //格式化消息模板36 $resultStr = sprintf($textTpl,$fromUsername,$toUsername,37 $time,$msgType,$contentStr);38 echo $resultStr; //输出结果39 }40}41?&gt;把代码保存为index.php并上传至http://www.worileqing.top/weixin/目录，如果刚才没删除该文件，则直接覆盖。 现在用户通过微信公众平台发送任何消息公众账号均会返回一条内容为“http://www.worileqing.top”的消息。接下来需要做的就是根据用户消息动态返回结果~ SimSimi（小黄鸡）是目前比较火的聊天机器人，我用CURL开发了一个免费的SimSimi（小黄鸡）接口，传入关键词会返回文本回复，这部分不是本文重点，就不多说明，直接上代码(2014.07.28更新):01把上面两段代码整合在一起就大功告成了，需要说明一点，微信服务器在5秒内收不到响应会断掉连接，通过此接口有可能会超时，且SimSimi已经屏蔽了BAE和SAE上的抓取请求，推荐使用SimSimi官方收费API，速度比较快~","tags":[]}]